C51 COMPILER V9.59.0.0   MAIN                                                              10/04/2018 12:21:18 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <N76E003.h>
   2          #include <SVPWM.h>
   3          #include <3PhaseInverter.h>
   4          #include <BLDC with Hall.h>
   5          #include "intrins.h"
   6          
   7          bit SVPWMmode = 0;
   8          bit ReverseSpin = 1;
   9          
  10          const ElecAngleOffestCCW = 267;
  11          const StableCount = 4;
  12          const ElecAngleOffestCW = 318;
  13          unsigned char SpeedRippleLimitforSVP = 4;
  14          unsigned int SpeedLowLimitforSVP = 2400;
  15          unsigned int SatiSCyclesSwSVP = 0;
  16          unsigned char Stablecnt = 0;
  17          
  18          unsigned int SpeedCount = 0;
  19          unsigned char PrevoiusMechinalCycle = 0;
  20          unsigned long CalcElectricAngle = 0;
  21          unsigned int Previous1MechanicalDelay, Previous2MechanicalDelay, CurrentElectricAngle, PreviousElectricAng
             -le;
  22          
  23          unsigned char code number[]={'0','1','2','3','4','5','6','7','8','9',}; 
  24          sbit debug = P1^6;
  25          
  26          #define FOSC            30000000UL
  27          #define BRT             (65536 - FOSC / 115200 / 4)
  28          
  29          bit busy;
  30          char wptr;
  31          char rptr;
  32          char buffer[16];
  33          
  34          void UartIsr() interrupt 4 using 1
  35          {
  36   1          if (TI)
  37   1          {
  38   2              TI = 0;
  39   2              busy = 0;
  40   2          }
  41   1          if (RI)
  42   1          {
  43   2              RI = 0;
  44   2              buffer[wptr++] = SBUF;
  45   2              wptr &= 0x0f;
  46   2          }
  47   1      }
  48          
  49          void UartInit()
  50          {
  51   1       /*   SCON = 0x50;
  52   1          T2L = BRT;
  53   1          T2H = BRT >> 8;
C51 COMPILER V9.59.0.0   MAIN                                                              10/04/2018 12:21:18 PAGE 2   

  54   1          AUXR = 0x15;
  55   1          wptr = 0x00;
  56   1          rptr = 0x00;
  57   1          busy = 0;*/
  58   1      }
  59          
  60          void UartSend(char dat)
  61          {
  62   1          while (busy);
  63   1          busy = 1;
  64   1          SBUF = dat;
  65   1      }
  66          
  67          void UartSendStr(char *p)
  68          {
  69   1          while (*p)
  70   1          {
  71   2              UartSend(*p++);
  72   2          }
  73   1      }
  74          
  75          
  76          void delay(unsigned long t)
  77          {
  78   1        while(t--);
  79   1      }
  80          
  81          
  82          void TM1_Isr() interrupt 3
  83          {
  84   1        unsigned char CurrentMechinalCycle;   
  85   1        unsigned int EstimateSpeedCountByHall = 0;
  86   1        
  87   1        TR1 = 0;
  88   1        TF1 = 0;
  89   1        TH1 = 0xb8;
  90   1        TL1 = 0x24;
  91   1        ET1 = 0;
  92   1        TR1 = 1;
  93   1      
  94   1        
  95   1        if(SpeedCount < 60000) SpeedCount++;
  96   1        if(SpeedCount >= Previous1MechanicalDelay + (Previous1MechanicalDelay >> SpeedRippleLimitforSVP))
  97   1        {
  98   2          if(SVPWMmode)
  99   2          {
 100   3            debug = 1;
 101   3            SVPWMmode = 0;
 102   3            Stablecnt = 0;
 103   3          }
 104   2        }
 105   1        CurrentMechinalCycle = DetermineCurrentElecCycle(0);
 106   1        if(PrevoiusMechinalCycle != CurrentMechinalCycle)
 107   1        {
 108   2          if(ReverseSpin)
 109   2            switch(CurrentMechinalCycle)
 110   2            {
 111   3              case 6:
 112   3                Previous2MechanicalDelay = Previous1MechanicalDelay;
 113   3                Previous1MechanicalDelay = SpeedCount;
 114   3                SpeedCount = 0; 
 115   3                if((Previous1MechanicalDelay <= SpeedLowLimitforSVP) && ((Previous1MechanicalDelay >= Previous2Mechan
C51 COMPILER V9.59.0.0   MAIN                                                              10/04/2018 12:21:18 PAGE 3   

             -icalDelay - (Previous2MechanicalDelay >> SpeedRippleLimitforSVP)) && (Previous1MechanicalDelay <= Previous2MechanicalDel
             -ay + (Previous2MechanicalDelay >> SpeedRippleLimitforSVP))))
 116   3                {
 117   4                  debug = 0;
 118   4                  if(Stablecnt >= 4)
 119   4                  {
 120   5                    SVPWMmode = 1;
 121   5                  }
 122   4                  else
 123   4                    Stablecnt += 1;
 124   4                }
 125   3                else
 126   3                {
 127   4                  debug = 1;
 128   4                  Stablecnt = 0;
 129   4                  SVPWMmode = 0;
 130   4                }
 131   3                break;
 132   3              case 5:
 133   3                EstimateSpeedCountByHall = Previous1MechanicalDelay * 1 / 6;    
 134   3                break;
 135   3              case 4:
 136   3                EstimateSpeedCountByHall = Previous1MechanicalDelay * 2 / 6;    
 137   3                break;
 138   3              case 3:
 139   3                EstimateSpeedCountByHall = Previous1MechanicalDelay * 3 / 6;     
 140   3                break;
 141   3              case 2:
 142   3                EstimateSpeedCountByHall = Previous1MechanicalDelay * 4 / 6;    
 143   3                break;
 144   3              case 1:
 145   3                EstimateSpeedCountByHall = Previous1MechanicalDelay * 5 / 6;    
 146   3                break;
 147   3            }
 148   2          else switch(CurrentMechinalCycle)
 149   2            {
 150   3              case 1:
 151   3                Previous2MechanicalDelay = Previous1MechanicalDelay;
 152   3                Previous1MechanicalDelay = SpeedCount;
 153   3                SpeedCount = 0; 
 154   3                if((Previous1MechanicalDelay <= SpeedLowLimitforSVP) && ((Previous1MechanicalDelay >= Previous2Mechan
             -icalDelay - (Previous2MechanicalDelay >> SpeedRippleLimitforSVP)) && (Previous1MechanicalDelay <= Previous2MechanicalDel
             -ay + (Previous2MechanicalDelay >> SpeedRippleLimitforSVP))))
 155   3                {   
 156   4                  debug = 0;
 157   4                  if(Stablecnt >= 4)
 158   4                  {
 159   5                    SVPWMmode = 1;
 160   5                  }
 161   4                  else
 162   4                  Stablecnt += 1;
 163   4                }
 164   3                else
 165   3                {
 166   4                  debug = 1;
 167   4                  SVPWMmode = 0;
 168   4                  Stablecnt = 0;
 169   4                }
 170   3                break;
 171   3              case 2:
 172   3                EstimateSpeedCountByHall = Previous1MechanicalDelay * 1 / 6;        
 173   3                break;
C51 COMPILER V9.59.0.0   MAIN                                                              10/04/2018 12:21:18 PAGE 4   

 174   3              case 3:
 175   3                EstimateSpeedCountByHall = Previous1MechanicalDelay * 2 / 6;    
 176   3                break;
 177   3              case 4:
 178   3                EstimateSpeedCountByHall = Previous1MechanicalDelay * 3 / 6;     
 179   3                break;
 180   3              case 5:
 181   3                EstimateSpeedCountByHall = Previous1MechanicalDelay * 4 / 6;    
 182   3                break;
 183   3              case 6:
 184   3                EstimateSpeedCountByHall = Previous1MechanicalDelay * 5 / 6;    
 185   3                break;
 186   3            }
 187   2          }
 188   1        if(SpeedCount != 0)
 189   1        {
 190   2          if(EstimateSpeedCountByHall > SpeedCount)
 191   2          {
 192   3            if(EstimateSpeedCountByHall - SpeedCount > 15)
 193   3              SpeedCount = EstimateSpeedCountByHall;
 194   3          }
 195   2          else
 196   2          {
 197   3            if(SpeedCount - SpeedCount > 15)
 198   3              SpeedCount = EstimateSpeedCountByHall;
 199   3          }
 200   2        }
 201   1        PrevoiusMechinalCycle = CurrentMechinalCycle;
 202   1        CalcElectricAngle = (unsigned long)SpeedCount * 719 / ((unsigned long)Previous1MechanicalDelay + (unsigne
             -d long)Previous2MechanicalDelay);
 203   1        if(SVPWMmode)
 204   1        {   
 205   2            if(CalcElectricAngle <= 360)
 206   2            {
 207   3              //CalcElectricAngle = CalcElectricAngle % 360;
 208   3            if(ReverseSpin)
 209   3              CalcElectricAngle += ElecAngleOffestCW;
 210   3            else
 211   3              CalcElectricAngle += ElecAngleOffestCCW;
 212   3            if(CalcElectricAngle >= 360) 
 213   3              CalcElectricAngle -= 360;
 214   3            if(ReverseSpin)
 215   3              CalcElectricAngle = 360 - CalcElectricAngle;
 216   3            CalculateInverterVectorsWidth_Polar(CalcElectricAngle, 22);
 217   3          }
 218   2        }
 219   1        else
 220   1        {
 221   2          BLDCTimerEventHandler();
 222   2        }
 223   1        PreviousElectricAngle = CalcElectricAngle;
 224   1        ET1 = 1;
 225   1      }
 226          
 227          void UART_Write_Int_Value(unsigned int num)
 228          {
 229   1        UartSend(number[num%1000/100]);
 230   1        UartSend(number[num%100/10]);
 231   1        UartSend(number[num%10]);
 232   1      }
 233          
 234          void TimerInit()
C51 COMPILER V9.59.0.0   MAIN                                                              10/04/2018 12:21:18 PAGE 5   

 235          {
 236   1        CKCON |= 0X18;
 237   1        TMOD = 0x00;       
 238   1        TH1 = 0x70;
 239   1        TL1 = 0x24;
 240   1        TR1 = 1;      
 241   1        ET1 = 1;
 242   1        EA = 1;
 243   1      }
 244          
 245          void PWM_Interrupu_Init()
 246          {
 247   1        EIE |= 0X08;
 248   1      }
 249          
 250          void PWM_Interr_ISR() interrupt 13
 251          {
 252   1        UpdateHall();
 253   1      }
 254          
 255          void main(void)
 256          {
 257   1        unsigned int i;
 258   1      //  UartInit();
 259   1      //  ES = 1;
 260   1      //  EA = 1;
 261   1        P1M1 &= 0xbf;
 262   1        P1M2 |= 0x40;
 263   1        Inverter_ControlGPIO_Init();
 264   1        HallGpioInit();
 265   1        TimerInit();
 266   1        PWM_Interrupu_Init();
 267   1        SetBLDCDirPWM(18,1);
 268   1      //  UartSendStr("DAS02418");
 269   1        while(1)
 270   1        {
 271   2          for(i = 0;i <= 360;i ++)
 272   2          { 
 273   3            
 274   3        //  BLDCTimerEventHandler();
 275   3        //    UpdateBLDCInverter(i);
 276   3            delay(362);
 277   3      
 278   3          //  CalculateInverterVectorsWidth_Polar(i, 12);
 279   3      /*      UART_Write_Int_Value(CalcElectricAngle);
 280   3            if(HA)
 281   3              UartSendStr("HA+");
 282   3            else  
 283   3              UartSendStr("HA-");
 284   3            
 285   3            if(HB)
 286   3              UartSendStr("HB+");
 287   3            else  
 288   3              UartSendStr("HB-");
 289   3            
 290   3            if(HC)
 291   3              UartSendStr("HC+");
 292   3            else  
 293   3              UartSendStr("HC-");
 294   3            switch(DetermineCurrentElecCycle(0))
 295   3            {
 296   3              case 0:
C51 COMPILER V9.59.0.0   MAIN                                                              10/04/2018 12:21:18 PAGE 6   

 297   3                UartSendStr("HALL ERROR\r\n"); break;
 298   3              case 1:
 299   3                UartSendStr("HALL 1\r\n");break;
 300   3              case 2:
 301   3                UartSendStr("HALL 2\r\n");break;
 302   3              case 3:
 303   3                UartSendStr("HALL 3\r\n");break;
 304   3              case 4:
 305   3                UartSendStr("HALL 4\r\n");break;
 306   3              case 5:
 307   3                UartSendStr("HALL 5\r\n");break;
 308   3              case 6:
 309   3                UartSendStr("HALL 6\r\n");break;
 310   3            }*/
 311   3          }
 312   2        }
 313   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1161    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     45       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
