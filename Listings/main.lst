C51 COMPILER V9.59.0.0   MAIN                                                              03/07/2019 00:01:43 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <N76E003.h>
   2          #include <SVPWM.h>
   3          #include <3PhaseInverter.h>
   4          #include <BLDC with Hall.h>
   5          #include <BLDC_Sensorless.h>
   6          #include "intrins.h"
   7          //#include "NTC.c"
   8          
   9          unsigned char xdata StartUP_Process = 0;
  10          
  11          unsigned char xdata STARTUP_FREQUENCY = 10;
  12          unsigned char xdata STARTUP_END_FREQUENCY = 130;
  13          unsigned char xdata STARTUP_PWM = 23;
  14          unsigned char xdata STARTUP_END_PWM =  40;
  15          unsigned int xdata ACCELERATION_TIME = 1000;
  16          unsigned int xdata LOCK_POSITION_TIME = 500 ;  
  17          unsigned int xdata LOCK_POSITION_PWM = 26 ;  
  18          unsigned int xdata DIREACTION_CHANGE_DELAY = 400; 
  19          volatile unsigned char xdata BEMF_SWITCH_PHASE_DELAY = 4;
  20          volatile unsigned char data BEMF_Phaseswitch_Count = 0;
  21          
  22          
  23          bit SVPWMmode = 0;
  24          bit SVPReverseSpin = 1;
  25          bit ENABLE_SVPWM_FOR_SYNCM = 0;
  26          bit BLDC_SENSORLESS = 1;
  27          bit BEMF_PWM_ON_Detect = 0;
  28          volatile bit BEMF_Detect_Switch_Enable = 0;
  29          
  30          unsigned int xdata  DelayMsBetweenCurrentElectricalCycle = 0;
  31          unsigned int xdata  UsedStartupTime = 0; 
  32          unsigned int xdata  Accelerationtime = 0;
  33          unsigned int xdata  AccelerationFrequency = 0;   
  34          unsigned int  xdata AccelerationPWM = 0;
  35          unsigned long xdata  CurrentFrequency = 0;
  36          
  37          unsigned char InverterPWMValue = 0;
  38          
  39          unsigned char BLDC_SNSless_30degDLY = 0;
  40          unsigned char ElecAngleOffestCCW = 189;
  41          unsigned char StableCount = 10;
  42          unsigned char ElecAngleOffestCW = 215; // 238wm // 222
  43          unsigned char SVPAngleStep = 1;
  44          unsigned char SVPNextAngleStep = 1;
  45          unsigned char SpeedRippleLimitforSVP = 2;
  46          unsigned int pdata SpeedLowLimitforSVP = 6000;
  47          unsigned int pdata SatiSCyclesSwSVP = 0;
  48          unsigned char pdata Stablecnt = 0;
  49          unsigned int pdata SpeedCount = 0;
  50          unsigned char pdata PrevoiusMechinalCycle = 0;
  51          unsigned int CalcElectricAngle = 0;
  52          unsigned int SVPDriveAngle = 0;
  53          unsigned char SVPWMCurPWM = 0;
  54          unsigned char xdata ExecuteSVPBL_PWM = 0;
C51 COMPILER V9.59.0.0   MAIN                                                              03/07/2019 00:01:43 PAGE 2   

  55          unsigned int pdata PulseCount = 0;
  56          unsigned char SVP_Angle_Delay = 0;
  57          volatile unsigned int Previous1MechanicalDelay,Previous2MechanicalDelay;
  58          unsigned int pdata Previous1CaptureCnt,Previous2CaptureCnt,Previous3CaptureCnt,Previous4CaptureCnt;
  59          unsigned int pdata CurrentElectricAngle, PreviousElectricAngle;
  60          unsigned int pdata External_Analog_ADC_Value = 0;
  61          unsigned int Current_SENSE_ADC_Value = 0;
  62          volatile unsigned char data CurrentElectricCycle = 0;
  63          unsigned char ADC_SampleTimes = 0;
  64          unsigned char BLDC_Sensorless_Status = 0;
  65          
  66          
  67          unsigned char DC_Volt_ADC_Channel = 0;
  68          unsigned char BEMF_Volt_ADC_Channel = 0;
  69          
  70          static bit ADC_IsSampleCurrentFinishd = 0;
  71          //unsigned int NTC_ADC_Value;
  72          
  73          #define DC_VOLTAGE_SMPL 0
  74          #define BEMF_SMPL       1
  75          #define NTC_ADC         2 
  76          #define EXTERNAL_ANALOG 5 
  77          
  78          unsigned char data ADC_Sample_Sequence[]=
  79          {
  80          DC_VOLTAGE_SMPL ,
  81          BEMF_SMPL       ,
  82          NTC_ADC         , 
  83          DC_VOLTAGE_SMPL ,
  84          BEMF_SMPL       ,
  85          EXTERNAL_ANALOG , 
  86          };
  87          
  88          //unsigned char code number[]={'0','1','2','3','4','5','6','7','8','9',}; 
  89          sbit debug1 = P0^7;
  90          
  91          //#define FOSC            30000000UL
  92          //#define BRT             (65536 - FOSC / 115200 / 4)
  93          
  94          //bit busy;
  95          //char wptr;
  96          //char rptr;
  97          //char buffer[16];
  98          
  99          //void UartIsr() interrupt 4 using 1
 100          //{
 101          //    if (TI)
 102          //    {
 103          //        TI = 0;
 104          //        busy = 0;
 105          //    }
 106          //    if (RI)
 107          //    {
 108          //        RI = 0;
 109          //        buffer[wptr++] = SBUF;
 110          //        wptr &= 0x0f;
 111          //    }
 112          //}
 113          
 114          void UartInit()
 115          {
 116   1       /*   SCON = 0x50;
C51 COMPILER V9.59.0.0   MAIN                                                              03/07/2019 00:01:43 PAGE 3   

 117   1          T2L = BRT;
 118   1          T2H = BRT >> 8;
 119   1          AUXR = 0x15;
 120   1          wptr = 0x00;
 121   1          rptr = 0x00;
 122   1          busy = 0;*/
 123   1      }
 124          
 125          //void UartSend(char dat)
 126          //{
 127          //    while (busy);
 128          //    busy = 1;
 129          //    SBUF = dat;
 130          //}
 131          
 132          //void UartSendStr(char *p)
 133          //{
 134          //    while (*p)
 135          //    {
 136          //        UartSend(*p++);
 137          //    }
 138          //}
 139          
 140          //void UART_Write_Int_Value(unsigned int num)
 141          //{
 142          //  UartSend(number[num%1000/100]);
 143          //  UartSend(number[num%100/10]);
 144          //  UartSend(number[num%10]);
 145          //}
 146          
 147          void TimerInit()
 148          {
 149   1      //  CKCON |= 0X18;
 150   1        TMOD = 0x00; 
 151   1      
 152   1        if(BLDC_SENSORLESS)
 153   1        {
 154   2          T2MOD = 0X60; //Set Timer2 Params
 155   2          TH2 = TL2 = 0;
 156   2        }
 157   1        else
 158   1        {
 159   2          T2MOD = 0X69; //low speed 69 high speed 49 mid speed 59
 160   2            
 161   2          CAPCON0 |= 0X10;  //Hall Signal Capture
 162   2          CAPCON1 = 0X00;
 163   2          CAPCON2 = 0X10;
 164   2        //  CAPCON3 = 0X04;
 165   2          CAPCON3 = 0X08;
 166   2          RCMP2H = 0XFF;
 167   2          RCMP2H = 0XFE;
 168   2          EIE |= 0X04;    //input capture interrupt enable
 169   2        }
 170   1        
 171   1      //  RL3 = 0X00;
 172   1      //  RH3 = 0XF0;
 173   1        EIE1 |= 0X02;
 174   1      //  T3CON &= 0XEF;
 175   1      //  T3CON |= 0X08;
 176   1        
 177   1        TH1 = 0x70;
 178   1        TL1 = 0x24;
C51 COMPILER V9.59.0.0   MAIN                                                              03/07/2019 00:01:43 PAGE 4   

 179   1        
 180   1        T2CON |= 0X04;
 181   1        
 182   1        TMOD |= 0x01; 
 183   1        TL0 = 0xAB; 
 184   1        TH0 = 0x2F;
 185   1        TF0 = 0;
 186   1        TR0 = 1;
 187   1        ET0 = 1;
 188   1        
 189   1        //Pin interrupts settings
 190   1        PICON = 0XFD;       //P1 interrupts edge triggled
 191   1        PINEN |= 0X78;
 192   1        PIPEN |= 0X38;
 193   1        
 194   1        //IRQ Priority settings
 195   1        IP |= 0x00;       //ADC priority second
 196   1        IPH |= 0x40;
 197   1        
 198   1        EIP |= 0X80;
 199   1        EIPH |= 0X80;     //PWM priority first
 200   1        
 201   1        EIP1 |= 0x02;
 202   1        EIPH1 |= 0x02;
 203   1        
 204   1        EIE |= 0X02;      //Timer3 Interrupt enable
 205   1        
 206   1      //  TR1 = 1;     
 207   1      //  ET1 = 1;
 208   1        EA = 1;
 209   1      }
 210          
 211          void SetMotorSpin(unsigned char pwm, bit dir)
 212          {
 213   1        unsigned int blpwm;
 214   1        blpwm = pwm;
 215   1        SetBLDCDirPWM(blpwm,dir);
 216   1        SetSVPWMValue(pwm);
 217   1        SVPReverseSpin = dir;
 218   1        InverterPWMValue = pwm;
 219   1        BEMF_PWM_ON_Detect = pwm > 128;
 220   1      }
 221          
 222          
 223          void Pin_Interrupt_ISR() interrupt 7 using 3
 224          {
 225   1        if(PIF & 0x38)  //Motor Hall Signals Input
 226   1        {   
 227   2          PIF &= 0x00;
 228   2          //These codes used only for Square Wave BLDC Drive
 229   2          if(!BLDC_SENSORLESS && !SVPWMmode)
 230   2          {
 231   3            EA = 0;
 232   3            CurrentElectricCycle = DetermineCurrentElecCycle(GetBLDCDirectionU3());
 233   3            SetElecCycleU3(CurrentElectricCycle);
 234   3            UpdateBLDCInverter();
 235   3            EA = 1;
 236   3          }
 237   2        }
 238   1        if(PIF & 0x40)  // external clock input interrupt pin
 239   1        {
 240   2          PIF &= 0XB0;
C51 COMPILER V9.59.0.0   MAIN                                                              03/07/2019 00:01:43 PAGE 5   

 241   2          if(PulseCount < 0xff)
 242   2            PulseCount++;
 243   2        }
 244   1        PIF &= 0x00;
 245   1      }
 246          
 247          void Timer0_ISR() interrupt 1
 248          {
 249   1        TR0 = 0;
 250   1        TF0 = 0;
 251   1        TL0 = 0xAB; 
 252   1        TH0 = 0x2F;
 253   1        PulseCount = 64;
 254   1        if(ExecuteSVPBL_PWM < PulseCount) ExecuteSVPBL_PWM++;
 255   1        if(ExecuteSVPBL_PWM > PulseCount) ExecuteSVPBL_PWM--;
 256   1      //  SetMotorSpin(ExecuteSVPBL_PWM,1);
 257   1        PulseCount = 0;
 258   1        TR0 = 1;
 259   1      }
 260          
 261          void SetSpeedRange_SVPrecision() using 1
 262          {
 263   1        unsigned char i;
 264   1        switch(T2MOD)
 265   1        {
 266   2          case 0x69:
 267   2          {
 268   3          if(C0H < 1)
 269   3            i = 2;
 270   3          else if(C0H < 4)
 271   3            i = 1;
 272   3          else
 273   3            i = 0;
 274   3          break;
 275   3          }
 276   2          case 0x59:
 277   2          {
 278   3          if(C0H < 2)
 279   3            i = 2;
 280   3          else if(C0H < 6)
 281   3            i = 1;
 282   3          else
 283   3            i = 0;
 284   3          break;
 285   3          }
 286   2          case 0x49:
 287   2          {
 288   3          if(C0H < 4)
 289   3            i = 2;
 290   3          else if(C0H < 12)
 291   3            i = 1;
 292   3          else
 293   3            i = 0;
 294   3          break;
 295   3          }
 296   2        }
 297   1        SVPAngleStep = SVPNextAngleStep;
 298   1        switch(i)
 299   1        {
 300   2          default :
 301   2            T2MOD = 0x69;
 302   2            SVPNextAngleStep = 1;
C51 COMPILER V9.59.0.0   MAIN                                                              03/07/2019 00:01:43 PAGE 6   

 303   2          break;
 304   2          
 305   2          case 1 :
 306   2            T2MOD = 0x59;
 307   2            SVPNextAngleStep = 2;
 308   2          break;
 309   2          
 310   2          case 2 :
 311   2            T2MOD = 0x49;
 312   2            SVPNextAngleStep = 4;
 313   2          break;
 314   2        }
 315   1      }
 316          
 317          void PWM_Interrupu_Init()
 318          {
 319   1        EIE |= 0X08;
 320   1      }
 321           
 322          
 323          void UpdateSVPFreq(unsigned int n) using 3
 324          {
 325   1        T3CON &= 0XE7;
 326   1        RL3 = ~(n & 0xff);
 327   1        RH3 = ~(n >> 8);
 328   1        T3CON |= 0X08;
 329   1      }
 330          
 331          void UpdateBLDC_Dly(unsigned int n) using 3
 332          {
 333   1        T3CON &= 0XE7;
 334   1        T3CON &= 0xF8;
 335   1        T3CON |= 0X07;
 336   1        RL3 = ~(n & 0xff);
 337   1        RH3 = ~(n >> 8);
 338   1        T3CON |= 0X08;
 339   1      }
 340          
 341          
 342          void Input_Capture_Interrupt_ISR() interrupt 12 using 3
 343          {
 344   1        bit ripple = 0;
 345   1        CAPCON0 &= 0XFE;
 346   1        Previous2MechanicalDelay = Previous1MechanicalDelay;
 347   1        EADC = 0;
 348   1        Previous1MechanicalDelay = ((int)C0H << 8)+ C0L;
 349   1        EADC = 1;
 350   1        if(ENABLE_SVPWM_FOR_SYNCM)
 351   1        {
 352   2          if(SVPReverseSpin)
 353   2            SVPDriveAngle = ElecAngleOffestCW;
 354   2          else
 355   2            SVPDriveAngle = ElecAngleOffestCCW; 
 356   2          Previous4CaptureCnt = Previous3CaptureCnt;
 357   2          Previous3CaptureCnt = Previous2CaptureCnt;
 358   2          Previous2CaptureCnt = Previous1CaptureCnt;
 359   2          Previous1CaptureCnt = Previous1MechanicalDelay;
 360   2          if(SVP_Angle_Delay > 15)
 361   2          {
 362   3            SVP_Angle_Delay = 0;
 363   3          }
 364   2          switch(T2MOD)
C51 COMPILER V9.59.0.0   MAIN                                                              03/07/2019 00:01:43 PAGE 7   

 365   2          {
 366   3            case 0x49: break;
 367   3            case 0x59: Previous1MechanicalDelay <<= 1; break;
 368   3            case 0x69: Previous1MechanicalDelay <<= 2; break;
 369   3          }
 370   2          if(Previous4CaptureCnt > Previous3CaptureCnt)
 371   2          {
 372   3            if(Previous4CaptureCnt - Previous3CaptureCnt > 200)
 373   3            {
 374   4              ripple = 1;
 375   4            }
 376   3          }
 377   2          else
 378   2          {   
 379   3            if(Previous3CaptureCnt - Previous4CaptureCnt > 200)
 380   3            {
 381   4              ripple = 1;
 382   4            }
 383   3          }
 384   2          if(Previous3CaptureCnt > Previous2CaptureCnt)
 385   2          {
 386   3            if(Previous3CaptureCnt - Previous2CaptureCnt > 200)
 387   3            {
 388   4              ripple = 1;
 389   4            }
 390   3          }
 391   2          else
 392   2          {   
 393   3            if(Previous2CaptureCnt - Previous3CaptureCnt > 200)
 394   3            {
 395   4              ripple = 1;
 396   4            }
 397   3          }
 398   2          if(Previous2CaptureCnt > Previous1CaptureCnt)
 399   2          {
 400   3            if(Previous2CaptureCnt - Previous1CaptureCnt > 200)
 401   3            {
 402   4              ripple = 1;
 403   4            }
 404   3          }
 405   2          else
 406   2          {   
 407   3            if(Previous1CaptureCnt - Previous2CaptureCnt > 200)
 408   3            {
 409   4              ripple = 1;
 410   4            }
 411   3          }
 412   2          if(ripple)
 413   2          {
 414   3            UpdateSVPFreq(Previous1CaptureCnt); 
 415   3          }
 416   2          else
 417   2          {
 418   3            UpdateSVPFreq((Previous1CaptureCnt + Previous2CaptureCnt + Previous3CaptureCnt + Previous4CaptureCnt) >
             -> 2);  
 419   3          }
 420   2        /*  if(Previous2MechanicalDelay < Previous1MechanicalDelay)
 421   2          {
 422   2            if(ElecAngleOffestCW < 255)
 423   2            {
 424   2              ElecAngleOffestCW ++;
 425   2            }
C51 COMPILER V9.59.0.0   MAIN                                                              03/07/2019 00:01:43 PAGE 8   

 426   2          }
 427   2          else
 428   2          {
 429   2            if(ElecAngleOffestCW > 0)
 430   2            {
 431   2              ElecAngleOffestCW --;
 432   2            }
 433   2          }*/
 434   2          SetSpeedRange_SVPrecision();
 435   2          if((Previous1MechanicalDelay <= SpeedLowLimitforSVP) && ((Previous1MechanicalDelay >= Previous2Mechanica
             -lDelay - (Previous2MechanicalDelay >> SpeedRippleLimitforSVP)) && (Previous1MechanicalDelay <= Previous2MechanicalDelay 
             -+ (Previous2MechanicalDelay >> SpeedRippleLimitforSVP))))
 436   2          {
 437   3            if(Stablecnt >= 4)
 438   3            {
 439   4              if(ENABLE_SVPWM_FOR_SYNCM)
 440   4              {
 441   5                SVPWMmode = 1;
 442   5              }
 443   4            }
 444   3            else
 445   3              Stablecnt += 1;
 446   3          }
 447   2          else
 448   2          {
 449   3            Stablecnt = 0;
 450   3            SVPWMmode = 0;
 451   3          }
 452   2        }
 453   1      }
 454          
 455          void BLDC_SNSLess_StepXL() using 2
 456          {
 457   1          //30DEG delay Counting Start
 458   1          if(0)
 459   1          {
 460   2            if(CurrentElectricCycle<6)  CurrentElectricCycle+=1;
 461   2            else    
 462   2            {
 463   3              CurrentElectricCycle = 1;
 464   3            }
 465   2          }
 466   1          else
 467   1          { 
 468   2            if(CurrentElectricCycle>1)  CurrentElectricCycle-=1;
 469   2            else    
 470   2            {
 471   3              CurrentElectricCycle = 6; 
 472   3            }
 473   2          }
 474   1      }
 475          
 476          void Timer3_Interr_ISR() interrupt 16 using 2
 477          { 
 478   1        T3CON &= 0XEF;  //clear timer interrupt
 479   1        if(BLDC_SENSORLESS)
 480   1        { 
 481   2          SetBLDCPWM(InverterPWMValue);   
 482   2          BLDC_SNSLess_StepXL();
 483   2          if(BLDC_Sensorless_Status == BLDC_Run)
 484   2          {
 485   3            T3CON &= 0XE7;    //Timer3 Stop
C51 COMPILER V9.59.0.0   MAIN                                                              03/07/2019 00:01:43 PAGE 9   

 486   3            
 487   3            debug1 = 0;
 488   3          }
 489   2          SetElecCycleU2(CurrentElectricCycle);
 490   2          UpdateBLDCInverter();
 491   2          
 492   2          TH2 = TL2 = 0;
 493   2          TR2 = 1;
 494   2          
 495   2          //Calculate Startup Process
 496   2          if(BLDC_Sensorless_Status == BLDC_Startup)
 497   2          {
 498   3            CurrentFrequency =  STARTUP_FREQUENCY + (UsedStartupTime / (Accelerationtime / AccelerationFrequency ) 
             -) ;
 499   3            InverterPWMValue = STARTUP_PWM + (UsedStartupTime / (Accelerationtime / AccelerationPWM ) ) ; 
 500   3            DelayMsBetweenCurrentElectricalCycle = 10000 /  CurrentFrequency; 
 501   3            if(UsedStartupTime == 0)
 502   3            {
 503   4              UpdateBLDC_Dly(LOCK_POSITION_TIME * 125);     
 504   4              InverterPWMValue = LOCK_POSITION_PWM;
 505   4            } 
 506   3            else 
 507   3            {UpdateBLDC_Dly(DelayMsBetweenCurrentElectricalCycle * 12);}    
 508   3            if((UsedStartupTime > Accelerationtime))
 509   3            {
 510   4              //startup_failed
 511   4              BLDC_Sensorless_Status = BLDC_Run;      
 512   4              T3CON &= 0XE7;    //Timer3 Stop
 513   4              SetMotorSpin(250,1);
 514   4              
 515   4            }
 516   3            else
 517   3              UsedStartupTime = UsedStartupTime + DelayMsBetweenCurrentElectricalCycle; 
 518   3          }
 519   2        }
 520   1        if(ENABLE_SVPWM_FOR_SYNCM)
 521   1        {
 522   2          //These codes used only for SVPWM mode
 523   2          if(SVPDriveAngle < 255-SVPAngleStep)
 524   2            SVPDriveAngle += SVPAngleStep;
 525   2          else
 526   2          {
 527   3            SVPDriveAngle = 0;
 528   3            if(SVP_Angle_Delay < 255)
 529   3              SVP_Angle_Delay++;
 530   3          }
 531   2          CalcElectricAngle = SVPDriveAngle;
 532   2          if(SVPWMmode)
 533   2          {   
 534   3              if(SVPReverseSpin)
 535   3                CalcElectricAngle = 255 - CalcElectricAngle;
 536   3              CalculateInverterVectorsWidth_Polar(CalcElectricAngle);
 537   3          }
 538   2        }
 539   1      }
 540          
 541          void PWM_Interr_ISR() interrupt 13 using 0
 542          {
 543   1        PWMF = 0;
 544   1      }
 545          
 546          void ADC_CurrentShunt_Compare_Start(unsigned char elecc) using 1
C51 COMPILER V9.59.0.0   MAIN                                                              03/07/2019 00:01:43 PAGE 10  

 547          {
 548   1        ADCCON0 &= 0XF0;
 549   1        ADCCON0 |= 0X01;
 550   1        ADCCON1 = 0X07;
 551   1        ADCDLY = 5;
 552   1        ADCCON2 = 0x20; //enable fault brake
 553   1      //  ADCCON0 |= 0X40;
 554   1      }
*** WARNING C280 IN LINE 546 OF main.c: 'elecc': unreferenced local variable
 555          
 556          void ADC_Interrupt_ISR() interrupt 11 using 1
 557          {
 558   1        unsigned char i;
 559   1        bit currentsense_finish = 0;
 560   1        ADCF = 0;
 561   1        i = ADCCON0 & 0X07;
 562   1      //  debug1 = !debug1;
 563   1        switch(i)
 564   1        {
 565   2          case 0:
 566   2      //      NTC_ADC_Value = ADCRH << 4 + ADCRL;
 567   2            break;   //temperature adc
 568   2          case 1:
 569   2            Current_SENSE_ADC_Value = (ADCRH << 4) + ADCRL;
 570   2            ADC_IsSampleCurrentFinishd = 1;
 571   2            if(!BEMF_PWM_ON_Detect)
 572   2            { 
 573   3                if(BEMF_Calculate(CurrentElectricCycle) == CurrentElectricCycle)
 574   3                {
 575   4                  if((T3CON & 0X08)==0)
 576   4                  {     
 577   5                    // Timer2 30deg Counting
 578   5                    TR2 = 0;        
 579   5                    Previous2MechanicalDelay = Previous1MechanicalDelay;
 580   5                    if(BLDC_Sensorless_Status == BLDC_Run)
 581   5                      Previous1MechanicalDelay = (TH2 << 8) + TL2;
 582   5                    else
 583   5                      Previous1MechanicalDelay = 0;
 584   5                                
 585   5                    UpdateBLDC_Dly((Previous1MechanicalDelay + Previous2MechanicalDelay) >> 1);
 586   5                    debug1 = 1;
 587   5                  }
 588   4                }
 589   3            }
 590   2            break;  //current sense adc
 591   2          case 2:
 592   2            External_Analog_ADC_Value = (ADCRH << 4) + ADCRL;
 593   2            break;  //external analog input
 594   2          case 3:
 595   2            Set_Phase_U_Voltage_ADC_Value((ADCRH << 4) + ADCRL);
 596   2            break;  //bemf w channel
 597   2          case 4:   
 598   2            Set_Phase_V_Voltage_ADC_Value((ADCRH << 4) + ADCRL);
 599   2            break;  //bemf v channel
 600   2          case 5:
 601   2            Set_Phase_W_Voltage_ADC_Value((ADCRH << 4) + ADCRL);
 602   2            break;  //bemf u channel
 603   2        } 
 604   1      //  debug1 = 0;
 605   1        if(ADC_IsSampleCurrentFinishd)
 606   1        { 
 607   2          switch(ADC_Sample_Sequence[ADC_SampleTimes])
C51 COMPILER V9.59.0.0   MAIN                                                              03/07/2019 00:01:43 PAGE 11  

 608   2          {
 609   3            case DC_VOLTAGE_SMPL:
 610   3            {
 611   4              Start_BEMF_Detect_ADC(CurrentElectricCycle,1,BEMF_PWM_ON_Detect);
 612   4              break;
 613   4            }
 614   3            case BEMF_SMPL:
 615   3            {       
 616   4              Start_BEMF_Detect_ADC(CurrentElectricCycle,2,BEMF_PWM_ON_Detect);
 617   4              break;
 618   4            }
 619   3            case NTC_ADC:
 620   3            { 
 621   4                ADCCON0 &= 0XF0;
 622   4                ADCCON0 |= 0X00;
 623   4                ADCCON1 = 0X01;////
 624   4                ADCDLY = 0;
 625   4                ADCCON2 = 0x00;
 626   4                ADCCON0 |= 0X40;  //start adc     
 627   4              break;
 628   4            }
 629   3            case EXTERNAL_ANALOG:
 630   3            {
 631   4                ADCCON0 &= 0XF0;
 632   4                ADCCON0 |= 0X02;
 633   4                ADCCON1 = 0X01;////
 634   4                ADCDLY = 0;
 635   4                ADCCON2 = 0x00;
 636   4                ADCCON0 |= 0X40;  //start adc   
 637   4              break;
 638   4            }
 639   3          }
 640   2          ADC_IsSampleCurrentFinishd = 0;
 641   2        }
 642   1        else
 643   1        {
 644   2          ADC_CurrentShunt_Compare_Start(CurrentElectricCycle);
 645   2          if(BEMF_PWM_ON_Detect)
 646   2          {
 647   3            if(BEMF_Calculate(CurrentElectricCycle) == CurrentElectricCycle)
 648   3            {
 649   4              if((T3CON & 0X08)==0)
 650   4              {     
 651   5                // Timer2 30deg Counting
 652   5                TR2 = 0;        
 653   5                Previous2MechanicalDelay = Previous1MechanicalDelay;
 654   5                if(BLDC_Sensorless_Status == BLDC_Run)
 655   5                  Previous1MechanicalDelay = (TH2 << 8) + TL2;
 656   5                else
 657   5                  Previous1MechanicalDelay = 0;
 658   5                            
 659   5                UpdateBLDC_Dly((Previous1MechanicalDelay + Previous2MechanicalDelay) >> 1);
 660   5                debug1 = 1;
 661   5              }
 662   4            }
 663   3          }
 664   2        }
 665   1      //  debug1 = 1; 
 666   1        if(ADC_SampleTimes >= 5)
 667   1        {
 668   2            ADC_SampleTimes = 0;
 669   2        }
C51 COMPILER V9.59.0.0   MAIN                                                              03/07/2019 00:01:43 PAGE 12  

 670   1        else
 671   1        {
 672   2          ADC_SampleTimes += 1;
 673   2        }
 674   1      }
 675          
 676          void Set_Currrent_Limit_Threshold(unsigned int th)
 677          {
 678   1        ADCMPH = th >> 8; //current limit
 679   1        ADCMPL = th & 0xff;;
 680   1      }
 681          
 682          void ADCInit()
 683          {
 684   1        Set_Currrent_Limit_Threshold(0xfff);
 685   1        ADC_CurrentShunt_Compare_Start(CurrentElectricCycle);
 686   1        EADC = 1;
 687   1      }
 688          
 689          void BLDC_SNSless_Parms_Calc()
 690          {
 691   1        Accelerationtime = ACCELERATION_TIME * 10;
 692   1        AccelerationFrequency = STARTUP_END_FREQUENCY - STARTUP_FREQUENCY;
 693   1        AccelerationPWM  = STARTUP_END_PWM - STARTUP_PWM ;
 694   1      }
 695          
 696          void main(void)
 697          {
 698   1        unsigned int i;
 699   1      //  UartInit();
 700   1        Inverter_ControlGPIO_Init();
 701   1        HallGpioInit();
 702   1        BEMF_Gpio_ADCIN_Init();
 703   1        ADCInit();
 704   1        SetMotorSpin(30,1);
 705   1        TimerInit();
 706   1        BLDC_SNSless_Parms_Calc();
 707   1        
 708   1        BLDC_Sensorless_Status = BLDC_Startup;
 709   1        
 710   1        UpdateBLDC_Dly(418);
 711   1        
 712   1      //  PWM_Interrupu_Init();
 713   1        
 714   1        
 715   1        P0M1 &= 0x7f;
 716   1        P0M2 |= 0x80;
 717   1          
 718   1        P1M1 &= 0Xb0;
 719   1        P1M2 &= 0Xb0; 
 720   1        
 721   1        debug1 = 1;
 722   1        
 723   1      //  UartSendStr("DAS02418");
 724   1        while(1)
 725   1        {
 726   2          for(i = 0;i < 254;i += 1)
 727   2          { 
 728   3            
 729   3        //  BLDCTimerEventHandler();
 730   3        //    UpdateBLDCInverter(i);
 731   3      
C51 COMPILER V9.59.0.0   MAIN                                                              03/07/2019 00:01:43 PAGE 13  

 732   3            //CalculateInverterVectorsWidth_Polar(i);
 733   3      /*      UART_Write_Int_Value(CalcElectricAngle);
 734   3            if(HA)
 735   3              UartSendStr("HA+");
 736   3            else  
 737   3              UartSendStr("HA-");
 738   3            
 739   3            if(HB)
 740   3              UartSendStr("HB+");
 741   3            else  
 742   3              UartSendStr("HB-");
 743   3            
 744   3            if(HC)
 745   3              UartSendStr("HC+");
 746   3            else  
 747   3              UartSendStr("HC-");
 748   3            switch(DetermineCurrentElecCycle(0))
 749   3            {
 750   3              case 0:
 751   3                UartSendStr("HALL ERROR\r\n"); break;
 752   3              case 1:
 753   3                UartSendStr("HALL 1\r\n");break;
 754   3              case 2:
 755   3                UartSendStr("HALL 2\r\n");break;
 756   3              case 3:
 757   3                UartSendStr("HALL 3\r\n");break;
 758   3              case 4:
 759   3                UartSendStr("HALL 4\r\n");break;
 760   3              case 5:
 761   3                UartSendStr("HALL 5\r\n");break;
 762   3              case 6:
 763   3                UartSendStr("HALL 6\r\n");break;
 764   3            }*/
 765   3          }
 766   2        }
 767   1      }
*** WARNING C294 IN LINE 460 OF main.c: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2078    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     29    ----
   PDATA SIZE       =     24    ----
   DATA SIZE        =     32       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      7       3
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
