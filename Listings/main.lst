C51 COMPILER V9.59.0.0   MAIN                                                              10/03/2018 20:56:08 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <N76E003.h>
   2          #include <SVPWM.h>
   3          #include <3PhaseInverter.h>
   4          #include <BLDC with Hall.h>
   5          #include "intrins.h"
   6          
   7          bit SVPWMmode = 0;
   8          bit ReverseSpin = 1;
   9          
  10          const ElecAngleOffestCCW = 267;
  11          const StableCount = 4;
  12          const ElecAngleOffestCW = 318;
  13          unsigned char SpeedRippleLimitforSVP = 3;
  14          unsigned int SpeedLowLimitforSVP = 700;
  15          unsigned int SatiSCyclesSwSVP = 0;
  16          unsigned char Stablecnt = 0;
  17          
  18          unsigned int SpeedCount = 0;
  19          unsigned char PrevoiusMechinalCycle = 0;
  20          unsigned long CalcElectricAngle = 0;
  21          unsigned int Previous1MechanicalDelay, Previous2MechanicalDelay, CurrentElectricAngle, PreviousElectricAng
             -le;
  22          
  23          unsigned char code number[]={'0','1','2','3','4','5','6','7','8','9',}; 
  24          sbit debug = P0^6;
  25          
  26          #define FOSC            30000000UL
  27          #define BRT             (65536 - FOSC / 115200 / 4)
  28          
  29          bit busy;
  30          char wptr;
  31          char rptr;
  32          char buffer[16];
  33          
  34          void UartIsr() interrupt 4 using 1
  35          {
  36   1          if (TI)
  37   1          {
  38   2              TI = 0;
  39   2              busy = 0;
  40   2          }
  41   1          if (RI)
  42   1          {
  43   2              RI = 0;
  44   2              buffer[wptr++] = SBUF;
  45   2              wptr &= 0x0f;
  46   2          }
  47   1      }
  48          
  49          void UartInit()
  50          {
  51   1       /*   SCON = 0x50;
  52   1          T2L = BRT;
  53   1          T2H = BRT >> 8;
C51 COMPILER V9.59.0.0   MAIN                                                              10/03/2018 20:56:08 PAGE 2   

  54   1          AUXR = 0x15;
  55   1          wptr = 0x00;
  56   1          rptr = 0x00;
  57   1          busy = 0;*/
  58   1      }
  59          
  60          void UartSend(char dat)
  61          {
  62   1          while (busy);
  63   1          busy = 1;
  64   1          SBUF = dat;
  65   1      }
  66          
  67          void UartSendStr(char *p)
  68          {
  69   1          while (*p)
  70   1          {
  71   2              UartSend(*p++);
  72   2          }
  73   1      }
  74          
  75          
  76          void delay(unsigned long t)
  77          {
  78   1        while(t--);
  79   1      }
  80          
  81          
  82          void TM1_Isr() interrupt 3 using 0
  83          {
  84   1        unsigned char CurrentMechinalCycle;   
  85   1        
  86   1        TR1 = 0;
  87   1        TF1 = 0;
  88   1        TH1 = 0xB3;
  89   1        TL1 = 0x24;
  90   1        TR1 = 1;      
  91   1        
  92   1        if(SpeedCount < 60000) SpeedCount++;
  93   1        if(SpeedCount >= Previous1MechanicalDelay + (Previous1MechanicalDelay >> SpeedRippleLimitforSVP))
  94   1        {
  95   2          if(SVPWMmode)
  96   2          {
  97   3            debug = 1;
  98   3            SVPWMmode = 0;
  99   3            Stablecnt = 0;
 100   3          }
 101   2        }
 102   1        CurrentMechinalCycle = DetermineCurrentElecCycle(0);
 103   1        if(PrevoiusMechinalCycle != CurrentMechinalCycle)
 104   1        {
 105   2          if(ReverseSpin)
 106   2            switch(CurrentMechinalCycle)
 107   2            {
 108   3              case 6:
 109   3                Previous2MechanicalDelay = Previous1MechanicalDelay;
 110   3                Previous1MechanicalDelay = SpeedCount;
 111   3                SpeedCount = 0; 
 112   3                if((Previous1MechanicalDelay <= SpeedLowLimitforSVP) && ((Previous1MechanicalDelay >= Previous2Mechan
             -icalDelay - (Previous2MechanicalDelay >> SpeedRippleLimitforSVP)) && (Previous1MechanicalDelay <= Previous2MechanicalDel
             -ay + (Previous2MechanicalDelay >> SpeedRippleLimitforSVP))))
 113   3                {
C51 COMPILER V9.59.0.0   MAIN                                                              10/03/2018 20:56:08 PAGE 3   

 114   4                  debug = 0;
 115   4                  if(Stablecnt >= 4)
 116   4                  {
 117   5                    SVPWMmode = 1;
 118   5                  }
 119   4                  else
 120   4                    Stablecnt += 1;
 121   4                }
 122   3                else
 123   3                {
 124   4                  debug = 1;
 125   4                  Stablecnt = 0;
 126   4                  SVPWMmode = 0;
 127   4                }
 128   3                break;
 129   3          /*    case 5:
 130   3                SpeedCount = Previous1MechanicalDelay * 1 / 6;    
 131   3                break;
 132   3              case 4:
 133   3                SpeedCount = Previous1MechanicalDelay * 2 / 6;    
 134   3                break;
 135   3              case 3:
 136   3                SpeedCount = Previous1MechanicalDelay * 3 / 6;     
 137   3                break;
 138   3              case 2:
 139   3                SpeedCount = Previous1MechanicalDelay * 4 / 6;    
 140   3                break;
 141   3              case 1:
 142   3                SpeedCount = Previous1MechanicalDelay * 5 / 6;    
 143   3                break;*/
 144   3            }
 145   2          else switch(CurrentMechinalCycle)
 146   2            {
 147   3              case 1:
 148   3                Previous2MechanicalDelay = Previous1MechanicalDelay;
 149   3                Previous1MechanicalDelay = SpeedCount;
 150   3                SpeedCount = 0; 
 151   3                if((Previous1MechanicalDelay <= SpeedLowLimitforSVP) && ((Previous1MechanicalDelay >= Previous2Mechan
             -icalDelay - (Previous2MechanicalDelay >> SpeedRippleLimitforSVP)) && (Previous1MechanicalDelay <= Previous2MechanicalDel
             -ay + (Previous2MechanicalDelay >> SpeedRippleLimitforSVP))))
 152   3                {   
 153   4                  debug = 0;
 154   4                  if(Stablecnt >= 4)
 155   4                  {
 156   5                    SVPWMmode = 1;
 157   5                  }
 158   4                  else
 159   4                  Stablecnt += 1;
 160   4                }
 161   3                else
 162   3                {
 163   4                  debug = 1;
 164   4                  SVPWMmode = 0;
 165   4                  Stablecnt = 0;
 166   4                }
 167   3                break;
 168   3            /*  case 2:
 169   3                SpeedCount = Previous1MechanicalDelay * 1 / 6;    
 170   3                break;
 171   3              case 3:
 172   3                SpeedCount = Previous1MechanicalDelay * 2 / 6;    
 173   3                break;
C51 COMPILER V9.59.0.0   MAIN                                                              10/03/2018 20:56:08 PAGE 4   

 174   3              case 4:
 175   3                SpeedCount = Previous1MechanicalDelay * 3 / 6;     
 176   3                break;
 177   3              case 5:
 178   3                SpeedCount = Previous1MechanicalDelay * 4 / 6;    
 179   3                break;
 180   3              case 6:
 181   3                SpeedCount = Previous1MechanicalDelay * 5 / 6;    
 182   3                break;*/
 183   3            }
 184   2          }
 185   1        PrevoiusMechinalCycle = CurrentMechinalCycle;
 186   1        CalcElectricAngle = (unsigned long)SpeedCount * 719 / ((unsigned long)Previous1MechanicalDelay + (unsigne
             -d long)Previous2MechanicalDelay);
 187   1        if(SVPWMmode)
 188   1        {   
 189   2            if(CalcElectricAngle <= 360)
 190   2            {
 191   3              //CalcElectricAngle = CalcElectricAngle % 360;
 192   3            if(ReverseSpin)
 193   3              CalcElectricAngle += ElecAngleOffestCW;
 194   3            else
 195   3              CalcElectricAngle += ElecAngleOffestCCW;
 196   3            if(CalcElectricAngle >= 360) 
 197   3              CalcElectricAngle -= 360;
 198   3            if(ReverseSpin)
 199   3              CalcElectricAngle = 360 - CalcElectricAngle;
 200   3            CalculateInverterVectorsWidth_Polar(CalcElectricAngle, 128);
 201   3          }
 202   2        }
 203   1        else
 204   1        {
 205   2          BLDCTimerEventHandler();
 206   2        }
 207   1        PreviousElectricAngle = CalcElectricAngle;
 208   1      }
 209          
 210          void UART_Write_Int_Value(unsigned int num)
 211          {
 212   1        UartSend(number[num%1000/100]);
 213   1        UartSend(number[num%100/10]);
 214   1        UartSend(number[num%10]);
 215   1      }
 216          
 217          void TimerInit()
 218          {
 219   1        CKCON |= 0X18;
 220   1        TMOD = 0x00;       
 221   1        TH1 = 0x01;
 222   1        TL1 = 0x24;
 223   1        TR1 = 1;      
 224   1        ET1 = 1;
 225   1        EA = 1;
 226   1      }
 227          
 228          void PWM_Interrupu_Init()
 229          {
 230   1        EIE |= 0X08;
 231   1      }
 232          
 233          void PWM_Interr_ISR() interrupt 13
 234          {
C51 COMPILER V9.59.0.0   MAIN                                                              10/03/2018 20:56:08 PAGE 5   

 235   1        UpdateHall();
 236   1      }
 237          
 238          void main(void)
 239          {
 240   1        unsigned int i;
 241   1      //  UartInit();
 242   1      //  ES = 1;
 243   1      //  EA = 1;
 244   1        Inverter_ControlGPIO_Init();
 245   1        HallGpioInit();
 246   1        TimerInit();
 247   1        PWM_Interrupu_Init();
 248   1        SetBLDCSpeed(128);
 249   1      //  UartSendStr("DAS02418");
 250   1        while(1)
 251   1        {
 252   2          for(i = 0;i <= 360;i ++)
 253   2          { 
 254   3            
 255   3        //  BLDCTimerEventHandler();
 256   3        //    UpdateBLDCInverter(i);
 257   3            delay(362);
 258   3      
 259   3          //  CalculateInverterVectorsWidth_Polar(i, 12);
 260   3      /*      UART_Write_Int_Value(CalcElectricAngle);
 261   3            if(HA)
 262   3              UartSendStr("HA+");
 263   3            else  
 264   3              UartSendStr("HA-");
 265   3            
 266   3            if(HB)
 267   3              UartSendStr("HB+");
 268   3            else  
 269   3              UartSendStr("HB-");
 270   3            
 271   3            if(HC)
 272   3              UartSendStr("HC+");
 273   3            else  
 274   3              UartSendStr("HC-");
 275   3            switch(DetermineCurrentElecCycle(0))
 276   3            {
 277   3              case 0:
 278   3                UartSendStr("HALL ERROR\r\n"); break;
 279   3              case 1:
 280   3                UartSendStr("HALL 1\r\n");break;
 281   3              case 2:
 282   3                UartSendStr("HALL 2\r\n");break;
 283   3              case 3:
 284   3                UartSendStr("HALL 3\r\n");break;
 285   3              case 4:
 286   3                UartSendStr("HALL 4\r\n");break;
 287   3              case 5:
 288   3                UartSendStr("HALL 5\r\n");break;
 289   3              case 6:
 290   3                UartSendStr("HALL 6\r\n");break;
 291   3            }*/
 292   3          }
 293   2        }
 294   1      }


C51 COMPILER V9.59.0.0   MAIN                                                              10/03/2018 20:56:08 PAGE 6   

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    892    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     45       7
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
