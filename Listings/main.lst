C51 COMPILER V9.59.0.0   MAIN                                                              11/14/2022 14:23:37 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "N76E003.h"
   2          #include "SVPWM.h"
   3          #include "3PhaseInverter.h"
   4          #include "BLDC with Hall.h"
   5          #include "intrins.h"
   6          
   7          bit SVPWMmode = 0;
   8          bit SVPReverseSpin = 1;
   9          
  10          const ElecAngleOffestCCW = 189;
  11          const StableCount = 4;
  12          const ElecAngleOffestCW = 219; // 238wm // 222
  13          unsigned char SVPAngleStep = 1;
  14          unsigned char SVPNextAngleStep = 1;
  15          unsigned char SpeedRippleLimitforSVP = 4;
  16          unsigned int SpeedLowLimitforSVP = 6000;
  17          unsigned int SatiSCyclesSwSVP = 0;
  18          unsigned char Stablecnt = 0;
  19          unsigned int SpeedCount = 0;
  20          unsigned char PrevoiusMechinalCycle = 0;
  21          unsigned int CalcElectricAngle = 0;
  22          unsigned int SVPDriveAngle = 0;
  23          unsigned char SVPWMCurPWM = 0;
  24          unsigned char ExecuteSVPBL_PWM = 0;
  25          unsigned int PulseCount = 0;
  26          unsigned int Previous1MechanicalDelay, Previous2MechanicalDelay, CurrentElectricAngle, PreviousElectricAng
             -le;
  27          
  28          unsigned char code number[]={'0','1','2','3','4','5','6','7','8','9',}; 
  29          sbit debug1 = P0^2;
  30          
  31          #define FOSC            30000000UL
  32          #define BRT             (65536 - FOSC / 115200 / 4)
  33          
  34          bit busy;
  35          char wptr;
  36          char rptr;
  37          char buffer[16];
  38          
  39          void UartIsr() interrupt 4 using 1
  40          {
  41   1          if (TI)
  42   1          {
  43   2              TI = 0;
  44   2              busy = 0;
  45   2          }
  46   1          if (RI)
  47   1          {
  48   2              RI = 0;
  49   2              buffer[wptr++] = SBUF;
  50   2              wptr &= 0x0f;
  51   2          }
  52   1      }
  53          
C51 COMPILER V9.59.0.0   MAIN                                                              11/14/2022 14:23:37 PAGE 2   

  54          void UartInit()
  55          {
  56   1       /*   SCON = 0x50;
  57   1          T2L = BRT;
  58   1          T2H = BRT >> 8;
  59   1          AUXR = 0x15;
  60   1          wptr = 0x00;
  61   1          rptr = 0x00;
  62   1          busy = 0;*/
  63   1      }
  64          
  65          void UartSend(char dat)
  66          {
  67   1          while (busy);
  68   1          busy = 1;
  69   1          SBUF = dat;
  70   1      }
  71          
  72          void UartSendStr(char *p)
  73          {
  74   1          while (*p)
  75   1          {
  76   2              UartSend(*p++);
  77   2          }
  78   1      }
  79          
  80          
  81          void delay(unsigned long t)
  82          {
  83   1        while(t--);
  84   1      }
  85          
  86          void UART_Write_Int_Value(unsigned int num)
  87          {
  88   1        UartSend(number[num%1000/100]);
  89   1        UartSend(number[num%100/10]);
  90   1        UartSend(number[num%10]);
  91   1      }
  92          
  93          void TimerInit()
  94          {
  95   1      //  CKCON |= 0X18;
  96   1        TMOD = 0x00;   
  97   1        T2MOD = 0X69; //low speed 69 high speed 49 mid speed 59
  98   1        CAPCON0 |= 0X10;
  99   1        CAPCON1 = 0X00;
 100   1        CAPCON2 = 0X10;
 101   1        CAPCON3 = 0X04;
 102   1        RCMP2H = 0XFF;
 103   1        RCMP2H = 0XFE;
 104   1        
 105   1        RL3 = 0X00;
 106   1        RH3 = 0XF0;
 107   1        EIE1 |= 0X02;
 108   1        T3CON &= 0XEF;
 109   1        T3CON |= 0X08;
 110   1        
 111   1        TH1 = 0x70;
 112   1        TL1 = 0x24;
 113   1        EIE |= 0X04;
 114   1        
 115   1        T2CON |= 0X04;
C51 COMPILER V9.59.0.0   MAIN                                                              11/14/2022 14:23:37 PAGE 3   

 116   1        
 117   1        EIPH |= 0X04;
 118   1        EIP &= 0XFB;
 119   1        EIP |= 0X80;
 120   1        EIPH &= 0X7F;
 121   1        
 122   1        TMOD |= 0x01; 
 123   1        TL0 = 0xAB; 
 124   1        TH0 = 0x2F;
 125   1        TF0 = 0;
 126   1        TR0 = 1;
 127   1        ET0 = 1;
 128   1        
 129   1        PICON = 0XFD;
 130   1        PINEN |= 0X58;
 131   1        PIPEN |= 0X38;
 132   1        EIE |= 0X02;
 133   1        
 134   1        EIPH |= 0X80;
 135   1        EIP |= 0X80;
 136   1        
 137   1        EIP |= 0X26;
 138   1        
 139   1        EIPH1 |= 0X02;
 140   1        
 141   1      //  TR1 = 1;     
 142   1      //  ET1 = 1;
 143   1        EA = 1;
 144   1      }
 145          
 146          void SetMotorSpin(unsigned char pwm, bit dir)
 147          {
 148   1        unsigned int blpwm;
 149   1        blpwm = pwm;
 150   1        SetBLDCDirPWM(blpwm,dir);
 151   1        SetSVPWMValue(pwm);
 152   1        SVPReverseSpin = dir;
 153   1      }
 154          
 155          
 156          void Pin_Interrupt_ISR() interrupt 7
 157          {
 158   1        if(PIF & 0x38)
 159   1        {
 160   2        }
 161   1        if(PIF & 0x40)
 162   1        {
 163   2          PIF &= 0XB0;
 164   2          if(PulseCount < 0xff)
 165   2            PulseCount++;
 166   2        }
 167   1        PIF &= 0x00;
 168   1      }
 169          
 170          void Timer0_ISR() interrupt 1
 171          {
 172   1        TR0 = 0;
 173   1        TF0 = 0;
 174   1        TL0 = 0xAB; 
 175   1        TH0 = 0x2F;
 176   1        PulseCount = 64;
 177   1        if(ExecuteSVPBL_PWM < PulseCount) ExecuteSVPBL_PWM++;
C51 COMPILER V9.59.0.0   MAIN                                                              11/14/2022 14:23:37 PAGE 4   

 178   1        if(ExecuteSVPBL_PWM > PulseCount) ExecuteSVPBL_PWM--;
 179   1        //SetMotorSpin(ExecuteSVPBL_PWM,1);
 180   1        PulseCount = 0;
 181   1        TR0 = 1;
 182   1      }
 183          
 184          void SetSpeedRange_SVPrecision() using 1
 185          {
 186   1        unsigned char i;
 187   1        switch(T2MOD)
 188   1        {
 189   2          case 0x69:
 190   2          {
 191   3          if(C0H < 1)
 192   3            i = 2;
 193   3          else if(C0H < 3)
 194   3            i = 1;
 195   3          else
 196   3            i = 0;
 197   3          break;
 198   3          }
 199   2          case 0x59:
 200   2          {
 201   3          if(C0H < 2)
 202   3            i = 2;
 203   3          else if(C0H < 6)
 204   3            i = 1;
 205   3          else
 206   3            i = 0;
 207   3          break;
 208   3          }
 209   2          case 0x49:
 210   2          {
 211   3          if(C0H < 4)
 212   3            i = 2;
 213   3          else if(C0H < 12)
 214   3            i = 1;
 215   3          else
 216   3            i = 0;
 217   3          break;
 218   3          }
 219   2        }
 220   1        SVPAngleStep = SVPNextAngleStep;
 221   1        switch(i)
 222   1        {
 223   2          default :
 224   2            T2MOD = 0x69;
 225   2            SVPNextAngleStep = 1;
 226   2          break;
 227   2          
 228   2          case 1 :
 229   2            T2MOD = 0x59;
 230   2            SVPNextAngleStep = 2;
 231   2          break;
 232   2          
 233   2          case 2 :
 234   2            T2MOD = 0x49;
 235   2            SVPNextAngleStep = 4;
 236   2          break;
 237   2        }
 238   1      }
 239          
C51 COMPILER V9.59.0.0   MAIN                                                              11/14/2022 14:23:37 PAGE 5   

 240          void PWM_Interrupu_Init()
 241          {
 242   1        EIE |= 0X08;
 243   1      }
 244           
 245          
 246          void UpdateSVPFreq(unsigned char th, unsigned char tl) using 3
 247          {
 248   1        T3CON &= 0XE7;
 249   1        RL3 = tl;
 250   1        RH3 = th;
 251   1        T3CON |= 0X08;
 252   1      }
 253          
 254          
 255          void Input_Capture_Interrupt_ISR() interrupt 12 using 3
 256          {
 257   1        CAPCON0 &= 0XFE;
 258   1        if(SVPReverseSpin)
 259   1          SVPDriveAngle = ElecAngleOffestCW;
 260   1        else
 261   1          SVPDriveAngle = ElecAngleOffestCCW; 
 262   1        Previous2MechanicalDelay = Previous1MechanicalDelay;
 263   1        Previous1MechanicalDelay = ((int)C0H << 8)+ C0L;
 264   1        switch(T2MOD)
 265   1        {
 266   2          case 0x49: break;
 267   2          case 0x59: Previous1MechanicalDelay <<= 1; break;
 268   2          case 0x69: Previous1MechanicalDelay <<= 2; break;
 269   2        }
 270   1        UpdateSVPFreq(255-C0H,255-C0L); 
 271   1        SetSpeedRange_SVPrecision();
 272   1        if((Previous1MechanicalDelay <= SpeedLowLimitforSVP) && ((Previous1MechanicalDelay >= Previous2Mechanical
             -Delay - (Previous2MechanicalDelay >> SpeedRippleLimitforSVP)) && (Previous1MechanicalDelay <= Previous2MechanicalDelay +
             - (Previous2MechanicalDelay >> SpeedRippleLimitforSVP))))
 273   1        {
 274   2          if(Stablecnt >= 4)
 275   2          {
 276   3            SVPWMmode = 1;
 277   3          }
 278   2          else
 279   2            Stablecnt += 1;
 280   2        }
 281   1        else
 282   1        {
 283   2          Stablecnt = 0;
 284   2          SVPWMmode = 0;
 285   2        }
 286   1      }
 287          
 288          void Timer3_Interr_ISR() interrupt 16 using 1
 289          { 
 290   1        T3CON &= 0XEF;
 291   1        if(SVPDriveAngle < 251)
 292   1          SVPDriveAngle += SVPAngleStep;
 293   1        else
 294   1          SVPDriveAngle = 0;
 295   1        CalcElectricAngle = SVPDriveAngle;
 296   1        if(SVPWMmode)
 297   1        {   
 298   2            if(SVPReverseSpin)
 299   2              CalcElectricAngle = 255 - CalcElectricAngle;
C51 COMPILER V9.59.0.0   MAIN                                                              11/14/2022 14:23:37 PAGE 6   

 300   2          //  CalculateInverterVectorsWidth_Polar(CalcElectricAngle);
 301   2        }
 302   1        else
 303   1        {
 304   2          //BLDCTimerEventHandler();
 305   2        }
 306   1      }
 307          
 308          void PWM_Interr_ISR() interrupt 13 using 2
 309          {
 310   1        PWMF = 0;
 311   1        ADCCON0 |= 0X40;
 312   1      }
 313          
 314          
 315          void ADCInit()
 316          {
 317   1        ADCCON0 = 0X04;
 318   1        ADCCON1 = 0X07;
 319   1        ADCMPH = 0X19;
 320   1        ADCMPL = 0x00;
 321   1        ADCDLY = 28;
 322   1        ADCCON2 = 0xa0;
 323   1      }
 324          
 325          void main(void)
 326          {
 327   1        unsigned int i;
 328   1      //  UartInit();
 329   1      //  ES = 1;
 330   1      //  EA = 1;
 331   1        Inverter_ControlGPIO_Init();
 332   1        HallGpioInit();
 333   1        //ADCInit();
 334   1        SetMotorSpin(65,1);
 335   1        //TimerInit();
 336   1        //PWM_Interrupu_Init();
 337   1        
 338   1        P0M1 &= 0xfb;
 339   1        P0M2 |= 0x04;
 340   1          
 341   1        P1M1 &= 0Xb0;
 342   1        P1M2 &= 0Xb0; 
 343   1        
 344   1        debug1 = 1;
 345   1        
 346   1      //  UartSendStr("DAS02418");
 347   1        while(1)
 348   1        {
 349   2          for(i = 0;i < 254;i += 1)
 350   2          { 
 351   3            
 352   3        if(SVPDriveAngle < 251)
 353   3          SVPDriveAngle += SVPAngleStep;
 354   3        else
 355   3          SVPDriveAngle = 0;
 356   3        //  BLDCTimerEventHandler();
 357   3        //    UpdateBLDCInverter(i);
 358   3            delay(19);
 359   3      
 360   3          CalculateInverterVectorsWidth_Polar(i);
 361   3      /*      UART_Write_Int_Value(CalcElectricAngle);
C51 COMPILER V9.59.0.0   MAIN                                                              11/14/2022 14:23:37 PAGE 7   

 362   3            if(HA)
 363   3              UartSendStr("HA+");
 364   3            else  
 365   3              UartSendStr("HA-");
 366   3            
 367   3            if(HB)
 368   3              UartSendStr("HB+");
 369   3            else  
 370   3              UartSendStr("HB-");
 371   3            
 372   3            if(HC)
 373   3              UartSendStr("HC+");
 374   3            else  
 375   3              UartSendStr("HC-");
 376   3            switch(DetermineCurrentElecCycle(0))
 377   3            {
 378   3              case 0:
 379   3                UartSendStr("HALL ERROR\r\n"); break;
 380   3              case 1:
 381   3                UartSendStr("HALL 1\r\n");break;
 382   3              case 2:
 383   3                UartSendStr("HALL 2\r\n");break;
 384   3              case 3:
 385   3                UartSendStr("HALL 3\r\n");break;
 386   3              case 4:
 387   3                UartSendStr("HALL 4\r\n");break;
 388   3              case 5:
 389   3                UartSendStr("HALL 5\r\n");break;
 390   3              case 6:
 391   3                UartSendStr("HALL 6\r\n");break;
 392   3            }*/
 393   3          }
 394   2        }
 395   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    973    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     51      10
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
