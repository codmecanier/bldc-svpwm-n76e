C51 COMPILER V9.59.0.0   MAIN                                                              12/23/2018 18:24:00 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <N76E003.h>
   2          #include <SVPWM.h>
   3          #include <3PhaseInverter.h>
   4          #include <BLDC with Hall.h>
   5          #include "intrins.h"
   6          
   7          bit SVPWMmode = 1;
   8          bit SVPReverseSpin = 1;
   9          
  10          const ElecAngleOffestCCW = 189;
  11          const StableCount = 4;
  12          const ElecAngleOffestCW = 219; // 238wm // 222
  13          unsigned char SVPAngleStep = 1;
  14          unsigned char SVPNextAngleStep = 1;
  15          unsigned char SpeedRippleLimitforSVP = 2;
  16          unsigned int SpeedLowLimitforSVP = 2400;
  17          unsigned int SatiSCyclesSwSVP = 0;
  18          unsigned char Stablecnt = 0;
  19          unsigned int SpeedCount = 0;
  20          unsigned char PrevoiusMechinalCycle = 0;
  21          unsigned int CalcElectricAngle = 0;
  22          unsigned int SVPDriveAngle = 0;
  23          unsigned char SVPWMCurPWM = 0;
  24          unsigned int Previous1MechanicalDelay, Previous2MechanicalDelay, CurrentElectricAngle, PreviousElectricAng
             -le;
  25          
  26          unsigned char code number[]={'0','1','2','3','4','5','6','7','8','9',}; 
  27          sbit debug1 = P0^2;
  28          
  29          #define FOSC            30000000UL
  30          #define BRT             (65536 - FOSC / 115200 / 4)
  31          
  32          bit busy;
  33          char wptr;
  34          char rptr;
  35          char buffer[16];
  36          
  37          void UartIsr() interrupt 4 using 1
  38          {
  39   1          if (TI)
  40   1          {
  41   2              TI = 0;
  42   2              busy = 0;
  43   2          }
  44   1          if (RI)
  45   1          {
  46   2              RI = 0;
  47   2              buffer[wptr++] = SBUF;
  48   2              wptr &= 0x0f;
  49   2          }
  50   1      }
  51          
  52          void UartInit()
  53          {
C51 COMPILER V9.59.0.0   MAIN                                                              12/23/2018 18:24:00 PAGE 2   

  54   1       /*   SCON = 0x50;
  55   1          T2L = BRT;
  56   1          T2H = BRT >> 8;
  57   1          AUXR = 0x15;
  58   1          wptr = 0x00;
  59   1          rptr = 0x00;
  60   1          busy = 0;*/
  61   1      }
  62          
  63          void UartSend(char dat)
  64          {
  65   1          while (busy);
  66   1          busy = 1;
  67   1          SBUF = dat;
  68   1      }
  69          
  70          void UartSendStr(char *p)
  71          {
  72   1          while (*p)
  73   1          {
  74   2              UartSend(*p++);
  75   2          }
  76   1      }
  77          
  78          
  79          void delay(unsigned long t)
  80          {
  81   1        while(t--);
  82   1      }
  83          
  84          
  85          void TM1_Isr() interrupt 3 using 1
  86          {
  87   1        unsigned char CurrentMechinalCycle;   
  88   1        unsigned int EstimateSpeedCountByHall = 0;
  89   1        
  90   1        TR1 = 0;
  91   1        TF1 = 0;
  92   1        TH1 = 0xff;
  93   1        TL1 = 0x00;
  94   1        ET1 = 0;
  95   1        TR1 = 1;
  96   1          
  97   1      //  debug1 = 0;
  98   1      
  99   1        if(SpeedCount < 60000) SpeedCount++;
 100   1        if(SpeedCount >= Previous1MechanicalDelay + (Previous1MechanicalDelay >> SpeedRippleLimitforSVP))
 101   1        {
 102   2          if(SVPWMmode)
 103   2          {
 104   3            SVPWMmode = 0;
 105   3            Stablecnt = 0;
 106   3          }
 107   2        }
 108   1        CurrentMechinalCycle = DetermineCurrentElecCycle(0);
 109   1        if(PrevoiusMechinalCycle != CurrentMechinalCycle)
 110   1        {
 111   2          if(SVPReverseSpin)
 112   2            switch(CurrentMechinalCycle)
 113   2            {
 114   3              case 6:
 115   3                Previous2MechanicalDelay = Previous1MechanicalDelay;
C51 COMPILER V9.59.0.0   MAIN                                                              12/23/2018 18:24:00 PAGE 3   

 116   3                Previous1MechanicalDelay = SpeedCount;
 117   3                SpeedCount = 0; 
 118   3                if((Previous1MechanicalDelay <= SpeedLowLimitforSVP) && ((Previous1MechanicalDelay >= Previous2Mechan
             -icalDelay - (Previous2MechanicalDelay >> SpeedRippleLimitforSVP)) && (Previous1MechanicalDelay <= Previous2MechanicalDel
             -ay + (Previous2MechanicalDelay >> SpeedRippleLimitforSVP))))
 119   3                {
 120   4                  if(Stablecnt >= 4)
 121   4                  {
 122   5                    SVPWMmode = 1;
 123   5                  }
 124   4                  else
 125   4                    Stablecnt += 1;
 126   4                }
 127   3                else
 128   3                {
 129   4                  Stablecnt = 0;
 130   4                  SVPWMmode = 0;
 131   4                }
 132   3                break;
 133   3              case 5:
 134   3                EstimateSpeedCountByHall = Previous1MechanicalDelay * 1 / 6;    
 135   3                break;
 136   3              case 4:
 137   3                EstimateSpeedCountByHall = Previous1MechanicalDelay * 2 / 6;    
 138   3                break;
 139   3              case 3:
 140   3                EstimateSpeedCountByHall = Previous1MechanicalDelay * 3 / 6;     
 141   3                break;
 142   3              case 2:
 143   3                EstimateSpeedCountByHall = Previous1MechanicalDelay * 4 / 6;    
 144   3                break;
 145   3              case 1:
 146   3                EstimateSpeedCountByHall = Previous1MechanicalDelay * 5 / 6;    
 147   3                break;
 148   3            }
 149   2          else switch(CurrentMechinalCycle)
 150   2            {
 151   3              case 1:
 152   3                Previous2MechanicalDelay = Previous1MechanicalDelay;
 153   3                Previous1MechanicalDelay = SpeedCount;
 154   3                SpeedCount = 0; 
 155   3                if((Previous1MechanicalDelay <= SpeedLowLimitforSVP) && ((Previous1MechanicalDelay >= Previous2Mechan
             -icalDelay - (Previous2MechanicalDelay >> SpeedRippleLimitforSVP)) && (Previous1MechanicalDelay <= Previous2MechanicalDel
             -ay + (Previous2MechanicalDelay >> SpeedRippleLimitforSVP))))
 156   3                {   
 157   4                  if(Stablecnt >= 4)
 158   4                  {
 159   5                    SVPWMmode = 1;
 160   5                  }
 161   4                  else
 162   4                  Stablecnt += 1;
 163   4                }
 164   3                else
 165   3                {
 166   4                  SVPWMmode = 0;
 167   4                  Stablecnt = 0;
 168   4                }
 169   3                break;
 170   3              case 2:
 171   3                EstimateSpeedCountByHall = Previous1MechanicalDelay * 1 / 6;        
 172   3                break;
 173   3              case 3:
C51 COMPILER V9.59.0.0   MAIN                                                              12/23/2018 18:24:00 PAGE 4   

 174   3                EstimateSpeedCountByHall = Previous1MechanicalDelay * 2 / 6;    
 175   3                break;
 176   3              case 4:
 177   3                EstimateSpeedCountByHall = Previous1MechanicalDelay * 3 / 6;     
 178   3                break;
 179   3              case 5:
 180   3                EstimateSpeedCountByHall = Previous1MechanicalDelay * 4 / 6;    
 181   3                break;
 182   3              case 6:
 183   3                EstimateSpeedCountByHall = Previous1MechanicalDelay * 5 / 6;    
 184   3                break;
 185   3            }
 186   2          }
 187   1        if(SpeedCount != 0)
 188   1        {
 189   2          if(EstimateSpeedCountByHall > SpeedCount)
 190   2          {
 191   3            if(EstimateSpeedCountByHall - SpeedCount > 15)
 192   3              SpeedCount = EstimateSpeedCountByHall;
 193   3          }
 194   2          else
 195   2          {
 196   3            if(SpeedCount - SpeedCount > 15)
 197   3              SpeedCount = EstimateSpeedCountByHall;
 198   3          }
 199   2        }
 200   1        PrevoiusMechinalCycle = CurrentMechinalCycle;
 201   1      //  CalcElectricAngle = ((unsigned long)SpeedCount << 9) / ((unsigned long)Previous1MechanicalDelay + (unsi
             -gned long)Previous2MechanicalDelay);
 202   1        if(SVPWMmode)
 203   1        {   
 204   2        /*    if(SVPReverseSpin)
 205   2              CalcElectricAngle += ElecAngleOffestCW;
 206   2            else
 207   2              CalcElectricAngle += ElecAngleOffestCCW;
 208   2            while(CalcElectricAngle >= 255) 
 209   2              CalcElectricAngle -= 255;
 210   2            if(SVPReverseSpin)
 211   2              CalcElectricAngle = 255 - CalcElectricAngle;
 212   2            CalculateInverterVectorsWidth_Polar(CalcElectricAngle);*/
 213   2        }
 214   1        else
 215   1        {
 216   2        //  BLDCTimerEventHandler();
 217   2        }
 218   1        ET1 = 1;
 219   1      //  debug1 = 1;
 220   1      }
 221          
 222          
 223          
 224          void UART_Write_Int_Value(unsigned int num)
 225          {
 226   1        UartSend(number[num%1000/100]);
 227   1        UartSend(number[num%100/10]);
 228   1        UartSend(number[num%10]);
 229   1      }
 230          
 231          void TimerInit()
 232          {
 233   1        CKCON |= 0X18;
 234   1        TMOD = 0x00;   
C51 COMPILER V9.59.0.0   MAIN                                                              12/23/2018 18:24:00 PAGE 5   

 235   1        T2MOD = 0X69; //low speed 69 high speed 49 mid speed 59
 236   1        CAPCON0 |= 0X10;
 237   1        CAPCON1 = 0X00;
 238   1        CAPCON2 = 0X10;
 239   1        CAPCON3 = 0X04;
 240   1        RCMP2H = 0XFF;
 241   1        RCMP2H = 0XFE;
 242   1        RL3 = 0X00;
 243   1        RH3 = 0XF0;
 244   1        EIE1 |= 0X02;
 245   1        T3CON &= 0XEF;
 246   1        T3CON |= 0X08;
 247   1        TH1 = 0x70;
 248   1        TL1 = 0x24;
 249   1        EIE |= 0X04;
 250   1        T2CON |= 0X04;
 251   1        EIPH |= 0X04;
 252   1        EIP &= 0XFB;
 253   1        EIP |= 0X80;
 254   1        EIPH &= 0X7F;
 255   1      //  TR1 = 1;     
 256   1      //  ET1 = 1;
 257   1        EA = 1;
 258   1      }
 259          
 260          void SetSpeedRange_SVPrecision() using 1
 261          {
 262   1        unsigned char i;
 263   1        switch(T2MOD)
 264   1        {
 265   2          case 0x69:
 266   2          {
 267   3          if(C0H < 1)
 268   3            i = 2;
 269   3          else if(C0H < 3)
 270   3            i = 1;
 271   3          else
 272   3            i = 0;
 273   3          break;
 274   3          }
 275   2          case 0x59:
 276   2          {
 277   3          if(C0H < 2)
 278   3            i = 2;
 279   3          else if(C0H < 6)
 280   3            i = 1;
 281   3          else
 282   3            i = 0;
 283   3          break;
 284   3          }
 285   2          case 0x49:
 286   2          {
 287   3          if(C0H < 4)
 288   3            i = 2;
 289   3          else if(C0H < 12)
 290   3            i = 1;
 291   3          else
 292   3            i = 0;
 293   3          break;
 294   3          }
 295   2        }
 296   1        SVPAngleStep = SVPNextAngleStep;
C51 COMPILER V9.59.0.0   MAIN                                                              12/23/2018 18:24:00 PAGE 6   

 297   1        switch(i)
 298   1        {
 299   2          default :
 300   2            T2MOD = 0x69;
 301   2            SVPNextAngleStep = 1;
 302   2          break;
 303   2          
 304   2          case 1 :
 305   2            T2MOD = 0x59;
 306   2            SVPNextAngleStep = 2;
 307   2          break;
 308   2          
 309   2          case 2 :
 310   2            T2MOD = 0x49;
 311   2            SVPNextAngleStep = 4;
 312   2          break;
 313   2        }
 314   1      }
 315          
 316          void PWM_Interrupu_Init()
 317          {
 318   1        EIE |= 0X08;
 319   1      }
 320           
 321          
 322          void UpdateSVPFreq(unsigned char th, unsigned char tl) using 3
 323          {
 324   1        T3CON &= 0XE7;
 325   1        RL3 = tl;
 326   1        RH3 = th;
 327   1        T3CON |= 0X08;
 328   1      }
 329          
 330          
 331          void Input_Capture_Interrupt_ISR() interrupt 12 using 3
 332          {
 333   1        unsigned int CapturePeriod;
 334   1        CAPCON0 &= 0XFE;
 335   1        if(SVPReverseSpin)
 336   1          SVPDriveAngle = ElecAngleOffestCW;
 337   1        else
 338   1          SVPDriveAngle = ElecAngleOffestCCW;
 339   1        UpdateSVPFreq(255-C0H,255-C0L); 
 340   1        SetSpeedRange_SVPrecision();
 341   1      }
*** WARNING C280 IN LINE 333 OF main.c: 'CapturePeriod': unreferenced local variable
 342          
 343          void Timer3_Interr_ISR() interrupt 16 using 1
 344          { 
 345   1        T3CON &= 0XEF;
 346   1        if(SVPDriveAngle < 251)
 347   1          SVPDriveAngle += SVPAngleStep;
 348   1        else
 349   1          SVPDriveAngle = 0;
 350   1        CalcElectricAngle = SVPDriveAngle;
 351   1        if(SVPWMmode)
 352   1        {   
 353   2            if(SVPReverseSpin)
 354   2              CalcElectricAngle = 255 - CalcElectricAngle;
 355   2            CalculateInverterVectorsWidth_Polar(CalcElectricAngle);
 356   2        }
 357   1        else
C51 COMPILER V9.59.0.0   MAIN                                                              12/23/2018 18:24:00 PAGE 7   

 358   1        {
 359   2          BLDCTimerEventHandler();
 360   2        }
 361   1      }
 362          
 363          void PWM_Interr_ISR() interrupt 13 using 2
 364          {
 365   1        PWMF = 0;
 366   1        ADCCON0 |= 0X40;
 367   1      }
 368          
 369          void SetMotorSpin(unsigned char pwm, bit dir)
 370          {
 371   1        unsigned int blpwm;
 372   1        blpwm = pwm;
 373   1        SetBLDCDirPWM(blpwm,dir);
 374   1        SetSVPWMVaue(pwm);
 375   1        SVPReverseSpin = dir;
 376   1      }
 377          
 378          void ADCInit()
 379          {
 380   1        ADCCON0 = 0X04;
 381   1        ADCCON1 = 0X07;
 382   1        ADCMPH = 0XF0;
 383   1        ADCMPL = 0x00;
 384   1        ADCDLY = 28;
 385   1        ADCCON2 = 0xa0;
 386   1      }
 387          
 388          void main(void)
 389          {
 390   1        unsigned int i;
 391   1      //  UartInit();
 392   1      //  ES = 1;
 393   1      //  EA = 1;
 394   1        Inverter_ControlGPIO_Init();
 395   1        HallGpioInit();
 396   1        ADCInit();
 397   1        SetMotorSpin(255,1);
 398   1        TimerInit();
 399   1      //  PWM_Interrupu_Init();
 400   1      //  SetSpeedRange_SVPrecision(2);
 401   1      //  SetSpeedRange_SVPrecision(2);
 402   1        
 403   1        P0M1 &= 0xfb;
 404   1        P0M2 |= 0x04;
 405   1        debug1 = 1;
 406   1        
 407   1      //  UartSendStr("DAS02418");
 408   1        while(1)
 409   1        {
 410   2          for(i = 0;i < 255;i += 1)
 411   2          { 
 412   3            
 413   3        //  BLDCTimerEventHandler();
 414   3        //    UpdateBLDCInverter(i);
 415   3            delay(3000);
 416   3      
 417   3        //  CalculateInverterVectorsWidth_Polar(i);
 418   3      /*      UART_Write_Int_Value(CalcElectricAngle);
 419   3            if(HA)
C51 COMPILER V9.59.0.0   MAIN                                                              12/23/2018 18:24:00 PAGE 8   

 420   3              UartSendStr("HA+");
 421   3            else  
 422   3              UartSendStr("HA-");
 423   3            
 424   3            if(HB)
 425   3              UartSendStr("HB+");
 426   3            else  
 427   3              UartSendStr("HB-");
 428   3            
 429   3            if(HC)
 430   3              UartSendStr("HC+");
 431   3            else  
 432   3              UartSendStr("HC-");
 433   3            switch(DetermineCurrentElecCycle(0))
 434   3            {
 435   3              case 0:
 436   3                UartSendStr("HALL ERROR\r\n"); break;
 437   3              case 1:
 438   3                UartSendStr("HALL 1\r\n");break;
 439   3              case 2:
 440   3                UartSendStr("HALL 2\r\n");break;
 441   3              case 3:
 442   3                UartSendStr("HALL 3\r\n");break;
 443   3              case 4:
 444   3                UartSendStr("HALL 4\r\n");break;
 445   3              case 5:
 446   3                UartSendStr("HALL 5\r\n");break;
 447   3              case 6:
 448   3                UartSendStr("HALL 6\r\n");break;
 449   3            }*/
 450   3          }
 451   2        }
 452   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1246    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     48      12
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
