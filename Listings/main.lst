C51 COMPILER V9.59.0.0   MAIN                                                              02/23/2019 21:54:48 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <N76E003.h>
   2          #include <SVPWM.h>
   3          #include <3PhaseInverter.h>
   4          #include <BLDC with Hall.h>
   5          #include <BLDC_Sensorless.h>
   6          #include "intrins.h"
   7          //#include "NTC.c"
   8          
   9          bit SVPWMmode = 0;
  10          bit SVPReverseSpin = 1;
  11          bit ENABLE_SVPWM_FOR_SYNCM = 0;
  12          bit BLDC_SENSORLESS = 1;
  13          bit BEMF_PWM_ON_Detect = 0;
  14          unsigned char BLDC_SNSless_30degDLY = 0;
  15          unsigned char ElecAngleOffestCCW = 189;
  16          unsigned char StableCount = 10;
  17          unsigned char ElecAngleOffestCW = 215; // 238wm // 222
  18          unsigned char SVPAngleStep = 1;
  19          unsigned char SVPNextAngleStep = 1;
  20          unsigned char SpeedRippleLimitforSVP = 2;
  21          unsigned int pdata SpeedLowLimitforSVP = 6000;
  22          unsigned int pdata SatiSCyclesSwSVP = 0;
  23          unsigned char pdata Stablecnt = 0;
  24          unsigned int pdata SpeedCount = 0;
  25          unsigned char pdata PrevoiusMechinalCycle = 0;
  26          unsigned int CalcElectricAngle = 0;
  27          unsigned int SVPDriveAngle = 0;
  28          unsigned char SVPWMCurPWM = 0;
  29          unsigned char xdata ExecuteSVPBL_PWM = 0;
  30          unsigned int pdata PulseCount = 0;
  31          unsigned char SVP_Angle_Delay = 0;
  32          unsigned int pdata Previous1CaptureCnt,Previous2CaptureCnt,Previous3CaptureCnt,Previous4CaptureCnt;
  33          unsigned int pdata Previous1MechanicalDelay, Previous2MechanicalDelay, CurrentElectricAngle, PreviousElect
             -ricAngle;
  34          unsigned int pdata External_Analog_ADC_Value = 0;
  35          unsigned int Current_SENSE_ADC_Value = 0;
  36          unsigned char pdata CurrentElectricCycle = 0;
  37          unsigned char ADC_SampleTimes = 0;
  38          
  39          unsigned char DC_Volt_ADC_Channel = 0;
  40          unsigned char BEMF_Volt_ADC_Channel = 0;
  41          
  42          static bit ADC_IsSampleCurrentFinishd = 0;
  43          //unsigned int NTC_ADC_Value;
  44          
  45          #define DC_VOLTAGE_SMPL 0
  46          #define BEMF_SMPL       1
  47          #define NTC_ADC         2 
  48          #define EXTERNAL_ANALOG 5 
  49          
  50          unsigned char data ADC_Sample_Sequence[]=
  51          {
  52          DC_VOLTAGE_SMPL ,
  53          BEMF_SMPL       ,
C51 COMPILER V9.59.0.0   MAIN                                                              02/23/2019 21:54:48 PAGE 2   

  54          NTC_ADC         , 
  55          DC_VOLTAGE_SMPL ,
  56          BEMF_SMPL       ,
  57          EXTERNAL_ANALOG , 
  58          };
  59          
  60          //unsigned char code number[]={'0','1','2','3','4','5','6','7','8','9',}; 
  61          sbit debug1 = P0^7;
  62          
  63          //#define FOSC            30000000UL
  64          //#define BRT             (65536 - FOSC / 115200 / 4)
  65          
  66          //bit busy;
  67          //char wptr;
  68          //char rptr;
  69          //char buffer[16];
  70          
  71          //void UartIsr() interrupt 4 using 1
  72          //{
  73          //    if (TI)
  74          //    {
  75          //        TI = 0;
  76          //        busy = 0;
  77          //    }
  78          //    if (RI)
  79          //    {
  80          //        RI = 0;
  81          //        buffer[wptr++] = SBUF;
  82          //        wptr &= 0x0f;
  83          //    }
  84          //}
  85          
  86          void UartInit()
  87          {
  88   1       /*   SCON = 0x50;
  89   1          T2L = BRT;
  90   1          T2H = BRT >> 8;
  91   1          AUXR = 0x15;
  92   1          wptr = 0x00;
  93   1          rptr = 0x00;
  94   1          busy = 0;*/
  95   1      }
  96          
  97          //void UartSend(char dat)
  98          //{
  99          //    while (busy);
 100          //    busy = 1;
 101          //    SBUF = dat;
 102          //}
 103          
 104          //void UartSendStr(char *p)
 105          //{
 106          //    while (*p)
 107          //    {
 108          //        UartSend(*p++);
 109          //    }
 110          //}
 111          
 112          //void UART_Write_Int_Value(unsigned int num)
 113          //{
 114          //  UartSend(number[num%1000/100]);
 115          //  UartSend(number[num%100/10]);
C51 COMPILER V9.59.0.0   MAIN                                                              02/23/2019 21:54:48 PAGE 3   

 116          //  UartSend(number[num%10]);
 117          //}
 118          
 119          void TimerInit()
 120          {
 121   1      //  CKCON |= 0X18;
 122   1        TMOD = 0x00;   
 123   1        T2MOD = 0X69; //low speed 69 high speed 49 mid speed 59
 124   1        CAPCON0 |= 0X10;
 125   1        CAPCON1 = 0X00;
 126   1        CAPCON2 = 0X10;
 127   1      //  CAPCON3 = 0X04;
 128   1        CAPCON3 = 0X08;
 129   1        RCMP2H = 0XFF;
 130   1        RCMP2H = 0XFE;
 131   1        
 132   1      //  RL3 = 0X00;
 133   1      //  RH3 = 0XF0;
 134   1        EIE1 |= 0X02;
 135   1      //  T3CON &= 0XEF;
 136   1      //  T3CON |= 0X08;
 137   1        
 138   1        TH1 = 0x70;
 139   1        TL1 = 0x24;
 140   1        EIE |= 0X04;    //input capture interrupt enable
 141   1        
 142   1        T2CON |= 0X04;
 143   1        
 144   1        TMOD |= 0x01; 
 145   1        TL0 = 0xAB; 
 146   1        TH0 = 0x2F;
 147   1        TF0 = 0;
 148   1        TR0 = 1;
 149   1        ET0 = 1;
 150   1        
 151   1        //Pin interrupts settings
 152   1        PICON = 0XFD;       //P1 interrupts edge triggled
 153   1        PINEN |= 0X78;
 154   1        PIPEN |= 0X38;
 155   1        
 156   1        //IRQ Priority settings
 157   1        IP |= 0x00;       //ADC priority second
 158   1        IPH |= 0x40;
 159   1        
 160   1        EIP |= 0X80;
 161   1        EIPH |= 0X80;     //PWM priority first
 162   1        
 163   1        EIP1 |= 0x02;
 164   1        EIPH1 |= 0x02;
 165   1        
 166   1        EIE |= 0X02;      //Timer3 Interrupt enable
 167   1        
 168   1      //  TR1 = 1;     
 169   1      //  ET1 = 1;
 170   1        EA = 1;
 171   1      }
 172          
 173          void SetMotorSpin(unsigned char pwm, bit dir)
 174          {
 175   1        unsigned int blpwm;
 176   1        blpwm = pwm;
 177   1        SetBLDCDirPWM(blpwm,dir);
C51 COMPILER V9.59.0.0   MAIN                                                              02/23/2019 21:54:48 PAGE 4   

 178   1        SetSVPWMValue(pwm);
 179   1        SVPReverseSpin = dir;
 180   1      }
 181          
 182          
 183          void Pin_Interrupt_ISR() interrupt 7 using 3
 184          {
 185   1        if(PIF & 0x38)  //Motor Hall Signals Input
 186   1        {   
 187   2          PIF &= 0x00;
 188   2          //These codes used only for Square Wave BLDC Drive
 189   2          EA = 0;
 190   2          CurrentElectricCycle = DetermineCurrentElecCycle(GetBLDCDirection());
*** WARNING C206 IN LINE 190 OF main.c: 'GetBLDCDirection': missing function-prototype
 191   2          UpdateBLDCInverter(CurrentElectricCycle);
 192   2          EA = 1;
 193   2        }
 194   1        if(PIF & 0x40)  // external clock input interrupt pin
 195   1        {
 196   2          PIF &= 0XB0;
 197   2          if(PulseCount < 0xff)
 198   2            PulseCount++;
 199   2        }
 200   1        PIF &= 0x00;
 201   1      }
 202          
 203          void Timer0_ISR() interrupt 1
 204          {
 205   1        TR0 = 0;
 206   1        TF0 = 0;
 207   1        TL0 = 0xAB; 
 208   1        TH0 = 0x2F;
 209   1        PulseCount = 64;
 210   1        if(ExecuteSVPBL_PWM < PulseCount) ExecuteSVPBL_PWM++;
 211   1        if(ExecuteSVPBL_PWM > PulseCount) ExecuteSVPBL_PWM--;
 212   1      //  SetMotorSpin(ExecuteSVPBL_PWM,1);
 213   1        PulseCount = 0;
 214   1        TR0 = 1;
 215   1      }
 216          
 217          void SetSpeedRange_SVPrecision() using 1
 218          {
 219   1        unsigned char i;
 220   1        switch(T2MOD)
 221   1        {
 222   2          case 0x69:
 223   2          {
 224   3          if(C0H < 1)
 225   3            i = 2;
 226   3          else if(C0H < 4)
 227   3            i = 1;
 228   3          else
 229   3            i = 0;
 230   3          break;
 231   3          }
 232   2          case 0x59:
 233   2          {
 234   3          if(C0H < 2)
 235   3            i = 2;
 236   3          else if(C0H < 6)
 237   3            i = 1;
 238   3          else
C51 COMPILER V9.59.0.0   MAIN                                                              02/23/2019 21:54:48 PAGE 5   

 239   3            i = 0;
 240   3          break;
 241   3          }
 242   2          case 0x49:
 243   2          {
 244   3          if(C0H < 4)
 245   3            i = 2;
 246   3          else if(C0H < 12)
 247   3            i = 1;
 248   3          else
 249   3            i = 0;
 250   3          break;
 251   3          }
 252   2        }
 253   1        SVPAngleStep = SVPNextAngleStep;
 254   1        switch(i)
 255   1        {
 256   2          default :
 257   2            T2MOD = 0x69;
 258   2            SVPNextAngleStep = 1;
 259   2          break;
 260   2          
 261   2          case 1 :
 262   2            T2MOD = 0x59;
 263   2            SVPNextAngleStep = 2;
 264   2          break;
 265   2          
 266   2          case 2 :
 267   2            T2MOD = 0x49;
 268   2            SVPNextAngleStep = 4;
 269   2          break;
 270   2        }
 271   1      }
 272          
 273          void PWM_Interrupu_Init()
 274          {
 275   1        EIE |= 0X08;
 276   1      }
 277           
 278          
 279          void UpdateSVPFreq(unsigned int n) using 3
 280          {
 281   1        T3CON &= 0XE7;
 282   1        RL3 = ~(n & 0xff);
 283   1        RH3 = ~(n >> 8);
 284   1        T3CON |= 0X08;
 285   1      }
 286          
 287          void UpdateBLDC_Dly(unsigned int n) using 3
 288          {
 289   1        T3CON &= 0XE7;
 290   1        T3CON &= 0xF8;
 291   1        T3CON |= 0X04;
 292   1        RL3 = ~(n & 0xff);
 293   1        RH3 = ~(n >> 8);
 294   1        T3CON |= 0X08;
 295   1      }
 296          
 297          
 298          void Input_Capture_Interrupt_ISR() interrupt 12 using 3
 299          {
 300   1        bit ripple = 0;
C51 COMPILER V9.59.0.0   MAIN                                                              02/23/2019 21:54:48 PAGE 6   

 301   1        CAPCON0 &= 0XFE;
 302   1        Previous2MechanicalDelay = Previous1MechanicalDelay;
 303   1        Previous1MechanicalDelay = ((int)C0H << 8)+ C0L;
 304   1        if(ENABLE_SVPWM_FOR_SYNCM)
 305   1        {
 306   2          if(SVPReverseSpin)
 307   2            SVPDriveAngle = ElecAngleOffestCW;
 308   2          else
 309   2            SVPDriveAngle = ElecAngleOffestCCW; 
 310   2          Previous4CaptureCnt = Previous3CaptureCnt;
 311   2          Previous3CaptureCnt = Previous2CaptureCnt;
 312   2          Previous2CaptureCnt = Previous1CaptureCnt;
 313   2          Previous1CaptureCnt = Previous1MechanicalDelay;
 314   2          if(SVP_Angle_Delay > 15)
 315   2          {
 316   3            SVP_Angle_Delay = 0;
 317   3          }
 318   2          switch(T2MOD)
 319   2          {
 320   3            case 0x49: break;
 321   3            case 0x59: Previous1MechanicalDelay <<= 1; break;
 322   3            case 0x69: Previous1MechanicalDelay <<= 2; break;
 323   3          }
 324   2          if(Previous4CaptureCnt > Previous3CaptureCnt)
 325   2          {
 326   3            if(Previous4CaptureCnt - Previous3CaptureCnt > 200)
 327   3            {
 328   4              ripple = 1;
 329   4            }
 330   3          }
 331   2          else
 332   2          {   
 333   3            if(Previous3CaptureCnt - Previous4CaptureCnt > 200)
 334   3            {
 335   4              ripple = 1;
 336   4            }
 337   3          }
 338   2          if(Previous3CaptureCnt > Previous2CaptureCnt)
 339   2          {
 340   3            if(Previous3CaptureCnt - Previous2CaptureCnt > 200)
 341   3            {
 342   4              ripple = 1;
 343   4            }
 344   3          }
 345   2          else
 346   2          {   
 347   3            if(Previous2CaptureCnt - Previous3CaptureCnt > 200)
 348   3            {
 349   4              ripple = 1;
 350   4            }
 351   3          }
 352   2          if(Previous2CaptureCnt > Previous1CaptureCnt)
 353   2          {
 354   3            if(Previous2CaptureCnt - Previous1CaptureCnt > 200)
 355   3            {
 356   4              ripple = 1;
 357   4            }
 358   3          }
 359   2          else
 360   2          {   
 361   3            if(Previous1CaptureCnt - Previous2CaptureCnt > 200)
 362   3            {
C51 COMPILER V9.59.0.0   MAIN                                                              02/23/2019 21:54:48 PAGE 7   

 363   4              ripple = 1;
 364   4            }
 365   3          }
 366   2          if(ripple)
 367   2          {
 368   3            UpdateSVPFreq(Previous1CaptureCnt); 
 369   3          }
 370   2          else
 371   2          {
 372   3            UpdateSVPFreq((Previous1CaptureCnt + Previous2CaptureCnt + Previous3CaptureCnt + Previous4CaptureCnt) >
             -> 2);  
 373   3          }
 374   2        /*  if(Previous2MechanicalDelay < Previous1MechanicalDelay)
 375   2          {
 376   2            if(ElecAngleOffestCW < 255)
 377   2            {
 378   2              ElecAngleOffestCW ++;
 379   2            }
 380   2          }
 381   2          else
 382   2          {
 383   2            if(ElecAngleOffestCW > 0)
 384   2            {
 385   2              ElecAngleOffestCW --;
 386   2            }
 387   2          }*/
 388   2          SetSpeedRange_SVPrecision();
 389   2          if((Previous1MechanicalDelay <= SpeedLowLimitforSVP) && ((Previous1MechanicalDelay >= Previous2Mechanica
             -lDelay - (Previous2MechanicalDelay >> SpeedRippleLimitforSVP)) && (Previous1MechanicalDelay <= Previous2MechanicalDelay 
             -+ (Previous2MechanicalDelay >> SpeedRippleLimitforSVP))))
 390   2          {
 391   3            if(Stablecnt >= 4)
 392   3            {
 393   4              if(ENABLE_SVPWM_FOR_SYNCM)
 394   4              {
 395   5                SVPWMmode = 1;
 396   5              }
 397   4            }
 398   3            else
 399   3              Stablecnt += 1;
 400   3          }
 401   2          else
 402   2          {
 403   3            Stablecnt = 0;
 404   3            SVPWMmode = 0;
 405   3          }
 406   2        }
 407   1      }
 408          
 409          void Timer3_Interr_ISR() interrupt 16 using 2
 410          { 
 411   1        T3CON &= 0XEF;  //clear timer interrupt
 412   1        if(BLDC_SENSORLESS)
 413   1        { 
 414   2          T3CON &= 0XE7;
 415   2          debug1 = 0;
 416   2        }
 417   1        if(ENABLE_SVPWM_FOR_SYNCM)
 418   1        {
 419   2          //These codes used only for SVPWM mode
 420   2          if(SVPDriveAngle < 255-SVPAngleStep)
 421   2            SVPDriveAngle += SVPAngleStep;
C51 COMPILER V9.59.0.0   MAIN                                                              02/23/2019 21:54:48 PAGE 8   

 422   2          else
 423   2          {
 424   3            SVPDriveAngle = 0;
 425   3            if(SVP_Angle_Delay < 255)
 426   3              SVP_Angle_Delay++;
 427   3          }
 428   2          CalcElectricAngle = SVPDriveAngle;
 429   2          if(SVPWMmode)
 430   2          {   
 431   3              if(SVPReverseSpin)
 432   3                CalcElectricAngle = 255 - CalcElectricAngle;
 433   3              CalculateInverterVectorsWidth_Polar(CalcElectricAngle);
 434   3          }
 435   2        }
 436   1      }
 437          
 438          void PWM_Interr_ISR() interrupt 13 using 0
 439          {
 440   1        PWMF = 0;
 441   1      }
 442          
 443          void ADC_CurrentShunt_Compare_Start(unsigned char elecc) using 1
 444          {
 445   1        ADCCON0 &= 0XF0;
 446   1        ADCCON0 |= 0X01;
 447   1        ADCCON1 = 0X07;
 448   1        ADCDLY = 5;
 449   1        ADCCON2 = 0x20; //enable fault brake
 450   1      //  ADCCON0 |= 0X40;
 451   1      }
*** WARNING C280 IN LINE 443 OF main.c: 'elecc': unreferenced local variable
 452          
 453          void ADC_Interrupt_ISR() interrupt 11 using 1
 454          {
 455   1        unsigned char i;
 456   1        bit currentsense_finish = 0;
 457   1        ADCF = 0;
 458   1        i = ADCCON0 & 0X07;
 459   1      //  debug1 = !debug1;
 460   1        switch(i)
 461   1        {
 462   2          case 0:
 463   2      //      NTC_ADC_Value = ADCRH << 4 + ADCRL;
 464   2            break;   //temperature adc
 465   2          case 1:
 466   2            Current_SENSE_ADC_Value = (ADCRH << 4) + ADCRL;
 467   2            ADC_IsSampleCurrentFinishd = 1;
 468   2            if(!BEMF_PWM_ON_Detect)
 469   2            { 
 470   3                if(BEMF_Calculate(CurrentElectricCycle))
 471   3                {
 472   4                  if((T3CON & 0x08) == 0)
 473   4                  {
 474   5                    UpdateBLDC_Dly(Previous1MechanicalDelay);
 475   5                    debug1 = 1;
 476   5                  }
 477   4                }
 478   3            }
 479   2            break;  //current sense adc
 480   2          case 2:
 481   2            External_Analog_ADC_Value = (ADCRH << 4) + ADCRL;
 482   2            break;  //external analog input
C51 COMPILER V9.59.0.0   MAIN                                                              02/23/2019 21:54:48 PAGE 9   

 483   2          case 3:
 484   2            Set_Phase_U_Voltage_ADC_Value((ADCRH << 4) + ADCRL);
 485   2            break;  //bemf w channel
 486   2          case 4:   
 487   2            Set_Phase_V_Voltage_ADC_Value((ADCRH << 4) + ADCRL);
 488   2            break;  //bemf v channel
 489   2          case 5:
 490   2            Set_Phase_W_Voltage_ADC_Value((ADCRH << 4) + ADCRL);
 491   2            break;  //bemf u channel
 492   2        } 
 493   1      //  debug1 = 0;
 494   1        if(ADC_IsSampleCurrentFinishd)
 495   1        { 
 496   2          switch(ADC_Sample_Sequence[ADC_SampleTimes])
 497   2          {
 498   3            case DC_VOLTAGE_SMPL:
 499   3            {
 500   4              Start_BEMF_Detect_ADC(CurrentElectricCycle,1,BEMF_PWM_ON_Detect);
 501   4              break;
 502   4            }
 503   3            case BEMF_SMPL:
 504   3            {       
 505   4              Start_BEMF_Detect_ADC(CurrentElectricCycle,2,BEMF_PWM_ON_Detect);
 506   4              break;
 507   4            }
 508   3            case NTC_ADC:
 509   3            { 
 510   4                ADCCON0 &= 0XF0;
 511   4                ADCCON0 |= 0X00;
 512   4                ADCCON1 = 0X01;////
 513   4                ADCDLY = 0;
 514   4                ADCCON2 = 0x00;
 515   4                ADCCON0 |= 0X40;  //start adc     
 516   4              break;
 517   4            }
 518   3            case EXTERNAL_ANALOG:
 519   3            {
 520   4                ADCCON0 &= 0XF0;
 521   4                ADCCON0 |= 0X02;
 522   4                ADCCON1 = 0X01;////
 523   4                ADCDLY = 0;
 524   4                ADCCON2 = 0x00;
 525   4                ADCCON0 |= 0X40;  //start adc   
 526   4              break;
 527   4            }
 528   3          }
 529   2          ADC_IsSampleCurrentFinishd = 0;
 530   2        }
 531   1        else
 532   1        {
 533   2          ADC_CurrentShunt_Compare_Start(CurrentElectricCycle);
 534   2          if(BEMF_PWM_ON_Detect)
 535   2          {
 536   3            if(BEMF_Calculate(CurrentElectricCycle))
 537   3            {
 538   4              if((T3CON & 0x08) == 0)
 539   4              {
 540   5                UpdateBLDC_Dly(Previous1MechanicalDelay);
 541   5                debug1 = 1;
 542   5              }
 543   4            }
 544   3          }
C51 COMPILER V9.59.0.0   MAIN                                                              02/23/2019 21:54:48 PAGE 10  

 545   2        }
 546   1      //  debug1 = 1; 
 547   1        if(ADC_SampleTimes >= 5)
 548   1        {
 549   2            ADC_SampleTimes = 0;
 550   2        }
 551   1        else
 552   1        {
 553   2          ADC_SampleTimes += 1;
 554   2        }
 555   1      }
 556          
 557          void Set_Currrent_Limit_Threshold(unsigned int th)
 558          {
 559   1        ADCMPH = th >> 8; //current limit
 560   1        ADCMPL = th & 0xff;;
 561   1      }
 562          
 563          void ADCInit()
 564          {
 565   1        Set_Currrent_Limit_Threshold(0xfff);
 566   1        ADC_CurrentShunt_Compare_Start(CurrentElectricCycle);
 567   1        EADC = 1;
 568   1      }
 569          
 570          void main(void)
 571          {
 572   1        unsigned int i;
 573   1      //  UartInit();
 574   1        Inverter_ControlGPIO_Init();
 575   1        HallGpioInit();
 576   1        BEMF_Gpio_ADCIN_Init();
 577   1        ADCInit();
 578   1        SetMotorSpin(92,1);
 579   1        TimerInit();
 580   1      //  PWM_Interrupu_Init();
 581   1        
 582   1        P0M1 &= 0x7f;
 583   1        P0M2 |= 0x80;
 584   1          
 585   1        P1M1 &= 0Xb0;
 586   1        P1M2 &= 0Xb0; 
 587   1        
 588   1        debug1 = 1;
 589   1        
 590   1      //  UartSendStr("DAS02418");
 591   1        while(1)
 592   1        {
 593   2          for(i = 0;i < 254;i += 1)
 594   2          { 
 595   3            
 596   3        //  BLDCTimerEventHandler();
 597   3        //    UpdateBLDCInverter(i);
 598   3      
 599   3            //CalculateInverterVectorsWidth_Polar(i);
 600   3      /*      UART_Write_Int_Value(CalcElectricAngle);
 601   3            if(HA)
 602   3              UartSendStr("HA+");
 603   3            else  
 604   3              UartSendStr("HA-");
 605   3            
 606   3            if(HB)
C51 COMPILER V9.59.0.0   MAIN                                                              02/23/2019 21:54:48 PAGE 11  

 607   3              UartSendStr("HB+");
 608   3            else  
 609   3              UartSendStr("HB-");
 610   3            
 611   3            if(HC)
 612   3              UartSendStr("HC+");
 613   3            else  
 614   3              UartSendStr("HC-");
 615   3            switch(DetermineCurrentElecCycle(0))
 616   3            {
 617   3              case 0:
 618   3                UartSendStr("HALL ERROR\r\n"); break;
 619   3              case 1:
 620   3                UartSendStr("HALL 1\r\n");break;
 621   3              case 2:
 622   3                UartSendStr("HALL 2\r\n");break;
 623   3              case 3:
 624   3                UartSendStr("HALL 3\r\n");break;
 625   3              case 4:
 626   3                UartSendStr("HALL 4\r\n");break;
 627   3              case 5:
 628   3                UartSendStr("HALL 5\r\n");break;
 629   3              case 6:
 630   3                UartSendStr("HALL 6\r\n");break;
 631   3            }*/
 632   3          }
 633   2        }
 634   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1585    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      1    ----
   PDATA SIZE       =     29    ----
   DATA SIZE        =     24       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      6       3
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
