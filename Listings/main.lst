C51 COMPILER V9.59.0.0   MAIN                                                              03/16/2019 10:48:28 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <N76E003.h>
   2          #include <SVPWM.h>
   3          #include <3PhaseInverter.h>
   4          #include <BLDC with Hall.h>
   5          #include <BLDC_Sensorless.h>
   6          #include "intrins.h"
   7          //#include "NTC.c"
   8          
   9          unsigned char xdata StartUP_Process = 0;
  10          
  11          unsigned char xdata STARTUP_FREQUENCY = 10;
  12          unsigned char xdata STARTUP_END_FREQUENCY = 70;
  13          unsigned char xdata STARTUP_PWM = 23;
  14          unsigned char xdata STARTUP_END_PWM = 50;
  15          unsigned int xdata ACCELERATION_TIME = 1000;
  16          unsigned int xdata LOCK_POSITION_TIME = 500 ;  
  17          unsigned int xdata LOCK_POSITION_PWM = 26 ;  
  18          unsigned int xdata DIREACTION_CHANGE_DELAY = 400; 
  19          
  20          
  21          bit SVPWMmode = 0;
  22          bit SVPReverseSpin = 1;
  23          bit ENABLE_SVPWM_FOR_SYNCM = 0;
  24          bit BLDC_SENSORLESS = 1;
  25          volatile bit BEMF_PWM_ON_Detect = 0;
  26          
  27          bit data CShunt_ADC_Interrupt = 0;
  28          
  29          unsigned char Adc_Smpl_Count = 0;
  30          
  31          unsigned int xdata  DelayMsBetweenCurrentElectricalCycle = 0;
  32          unsigned int xdata  UsedStartupTime = 0; 
  33          unsigned int xdata  Accelerationtime = 0;
  34          unsigned int xdata  AccelerationFrequency = 0;   
  35          unsigned int  xdata AccelerationPWM = 0;
  36          unsigned long xdata  CurrentFrequency = 0;
  37          
  38          unsigned char pdata BLDC_SNSLess_PWM = 0;
  39          unsigned char adcbemfreg0s,adcalterreg0s,bcrtnv = 0;
  40          
  41          unsigned char pdata ElecAngleOffestCCW = 189;
  42          unsigned char pdata StableCount = 10;
  43          unsigned char pdata ElecAngleOffestCW = 215; // 238wm // 222
  44          unsigned char pdata SVPAngleStep = 1;
  45          unsigned char pdata SVPNextAngleStep = 1;
  46          unsigned char pdata SpeedRippleLimitforSVP = 2;
  47          unsigned int pdata SpeedLowLimitforSVP = 6000;
  48          unsigned int pdata SatiSCyclesSwSVP = 0;
  49          unsigned char pdata Stablecnt = 0;
  50          unsigned int pdata SpeedCount = 0;
  51          unsigned char pdata PrevoiusMechinalCycle = 0;
  52          unsigned int pdata CalcElectricAngle = 0;
  53          unsigned int pdata  SVPDriveAngle = 0;
  54          unsigned char pdata SVPWMCurPWM = 0;
C51 COMPILER V9.59.0.0   MAIN                                                              03/16/2019 10:48:28 PAGE 2   

  55          unsigned char xdata ExecuteSVPBL_PWM = 0;
  56          unsigned int pdata PulseCount = 0;
  57          unsigned char pdata SVP_Angle_Delay = 0;
  58          volatile unsigned int pdata Previous1MechanicalDelay,Previous2MechanicalDelay;
  59          unsigned int pdata Previous1CaptureCnt,Previous2CaptureCnt,Previous3CaptureCnt,Previous4CaptureCnt;
  60          unsigned int pdata CurrentElectricAngle, PreviousElectricAngle;
  61          
  62          unsigned int data External_Analog_ADC_Value = 0;
  63          unsigned int data Current_SENSE_ADC_Value = 0;
  64          unsigned int data BEMF_ADC_Value = 0;
  65          unsigned int data DCBUS_ADC_Value = 0;
  66          
  67          volatile unsigned char pdata CurrentElectricCycle = 0;
  68          unsigned char ADC_SampleTimes = 0;
  69          unsigned char pdata BLDC_Sensorless_Status = 0;
  70          
  71          
  72          unsigned char pdata DC_Volt_ADC_Channel = 0;
  73          unsigned char pdata BEMF_Volt_ADC_Channel = 0;
  74          
  75          //unsigned int NTC_ADC_Value;
  76          
  77          #define DC_VOLTAGE_SMPL 0
  78          #define BEMF_SMPL       1
  79          #define NTC_ADC         2 
  80          #define EXTERNAL_ANALOG 5 
  81          
  82          const unsigned char BEMF_DCT_Params[6][3] = {
  83            {0,2,0},
  84            {0,1,1},
  85            {1,0,0},
  86            {1,2,1},
  87            {2,1,0},
  88            {2,0,1},
  89          };
  90          
  91          const unsigned char ADC_Sample_Sequence[]=
  92          {
  93            NTC_ADC,
  94            EXTERNAL_ANALOG , 
  95          };
  96          
  97          //unsigned char code number[]={'0','1','2','3','4','5','6','7','8','9',}; 
  98          sbit debug1 = P0^7;
  99          
 100          //#define FOSC            30000000UL
 101          //#define BRT             (65536 - FOSC / 115200 / 4)
 102          
 103          //bit busy;
 104          //char wptr;
 105          //char rptr;
 106          //char buffer[16];
 107          
 108          //void UartIsr() interrupt 4 using 1
 109          //{
 110          //    if (TI)
 111          //    {
 112          //        TI = 0;
 113          //        busy = 0;
 114          //    }
 115          //    if (RI)
 116          //    {
C51 COMPILER V9.59.0.0   MAIN                                                              03/16/2019 10:48:28 PAGE 3   

 117          //        RI = 0;
 118          //        buffer[wptr++] = SBUF;
 119          //        wptr &= 0x0f;
 120          //    }
 121          //}
 122          
 123          void UartInit()
 124          {
 125   1       /*   SCON = 0x50;
 126   1          T2L = BRT;
 127   1          T2H = BRT >> 8;
 128   1          AUXR = 0x15;
 129   1          wptr = 0x00;
 130   1          rptr = 0x00;
 131   1          busy = 0;*/
 132   1      }
 133          
 134          //void UartSend(char dat)
 135          //{
 136          //    while (busy);
 137          //    busy = 1;
 138          //    SBUF = dat;
 139          //}
 140          
 141          //void UartSendStr(char *p)
 142          //{
 143          //    while (*p)
 144          //    {
 145          //        UartSend(*p++);
 146          //    }
 147          //}
 148          
 149          //void UART_Write_Int_Value(unsigned int num)
 150          //{
 151          //  UartSend(number[num%1000/100]);
 152          //  UartSend(number[num%100/10]);
 153          //  UartSend(number[num%10]);
 154          //}
 155          
 156          void TimerInit()
 157          {
 158   1      //  CKCON |= 0X18;
 159   1        TMOD = 0x00; 
 160   1      
 161   1        if(BLDC_SENSORLESS)
 162   1        {
 163   2          T2MOD = 0X60; //Set Timer2 Params
 164   2          TH2 = TL2 = 0;
 165   2        }
 166   1        else
 167   1        {
 168   2          T2MOD = 0X69; //low speed 69 high speed 49 mid speed 59
 169   2            
 170   2          CAPCON0 |= 0X10;  //Hall Signal Capture
 171   2          CAPCON1 = 0X00;
 172   2          CAPCON2 = 0X10;
 173   2        //  CAPCON3 = 0X04;
 174   2          CAPCON3 = 0X08;
 175   2          RCMP2H = 0XFF;
 176   2          RCMP2H = 0XFE;
 177   2          EIE |= 0X04;    //input capture interrupt enable
 178   2        }
C51 COMPILER V9.59.0.0   MAIN                                                              03/16/2019 10:48:28 PAGE 4   

 179   1        
 180   1      //  RL3 = 0X00;
 181   1      //  RH3 = 0XF0;
 182   1        EIE1 |= 0X02;
 183   1      //  T3CON &= 0XEF;
 184   1      //  T3CON |= 0X08;
 185   1        
 186   1        TH1 = 0x70;
 187   1        TL1 = 0x24;
 188   1        
 189   1        T2CON |= 0X04;
 190   1        
 191   1        TMOD |= 0x01; 
 192   1        TL0 = 0xAB; 
 193   1        TH0 = 0x2F;
 194   1        TF0 = 0;
 195   1        TR0 = 1;
 196   1        ET0 = 1;
 197   1        
 198   1        //Pin interrupts settings
 199   1        PICON = 0XFD;       //P1 interrupts edge triggled
 200   1        PINEN |= 0X78;
 201   1        PIPEN |= 0X38;
 202   1        
 203   1        //IRQ Priority settings
 204   1        IP |= 0x00;       //ADC priority second
 205   1        IPH |= 0x40;
 206   1        
 207   1        EIP |= 0X80;
 208   1        EIPH |= 0X80;     //PWM priority first
 209   1        
 210   1        EIP1 |= 0x02;
 211   1        EIPH1 |= 0x02;
 212   1        
 213   1        EIE |= 0X02;      //Timer3 Interrupt enable
 214   1        
 215   1      //  TR1 = 1;     
 216   1      //  ET1 = 1;
 217   1        EA = 1;
 218   1      }
 219          
 220          void SetMotorSpin(unsigned char pwm, bit dir)
 221          {
 222   1        unsigned int blpwm;
 223   1        blpwm = pwm;
 224   1        SetBLDCDirPWM(blpwm,dir);
 225   1        SetSVPWMValue(pwm);
 226   1        SVPReverseSpin = dir;
 227   1        BLDC_SNSLess_PWM = pwm;
 228   1        BEMF_PWM_ON_Detect = pwm > 100;
 229   1      }
 230          
 231          
 232          void Pin_Interrupt_ISR() interrupt 7 using 3
 233          {
 234   1        if(PIF & 0x38)  //Motor Hall Signals Input
 235   1        {   
 236   2          PIF &= 0x00;
 237   2          //These codes used only for Square Wave BLDC Drive
 238   2          if(!BLDC_SENSORLESS && !SVPWMmode)
 239   2          {
 240   3            EA = 0;
C51 COMPILER V9.59.0.0   MAIN                                                              03/16/2019 10:48:28 PAGE 5   

 241   3            CurrentElectricCycle = DetermineCurrentElecCycle(GetBLDCDirectionU3());
 242   3            SetElecCycleU3(CurrentElectricCycle);
 243   3            UpdateBLDCInverter();
 244   3            EA = 1;
 245   3          }
 246   2        }
 247   1        if(PIF & 0x40)  // external clock input interrupt pin
 248   1        {
 249   2          PIF &= 0XB0;
 250   2          if(PulseCount < 0xff)
 251   2            PulseCount++;
 252   2        }
 253   1        PIF &= 0x00;
 254   1      }
 255          
 256          void Timer0_ISR() interrupt 1
 257          {
 258   1        TR0 = 0;
 259   1        TF0 = 0;
 260   1        TL0 = 0xAB; 
 261   1        TH0 = 0x2F;
 262   1        PulseCount = 64;
 263   1        if(ExecuteSVPBL_PWM < PulseCount) ExecuteSVPBL_PWM++;
 264   1        if(ExecuteSVPBL_PWM > PulseCount) ExecuteSVPBL_PWM--;
 265   1      //  SetMotorSpin(ExecuteSVPBL_PWM,1);
 266   1        PulseCount = 0;
 267   1        TR0 = 1;
 268   1      }
 269          
 270          void SetSpeedRange_SVPrecision() using 1
 271          {
 272   1        unsigned char i;
 273   1        switch(T2MOD)
 274   1        {
 275   2          case 0x69:
 276   2          {
 277   3          if(C0H < 1)
 278   3            i = 2;
 279   3          else if(C0H < 4)
 280   3            i = 1;
 281   3          else
 282   3            i = 0;
 283   3          break;
 284   3          }
 285   2          case 0x59:
 286   2          {
 287   3          if(C0H < 2)
 288   3            i = 2;
 289   3          else if(C0H < 6)
 290   3            i = 1;
 291   3          else
 292   3            i = 0;
 293   3          break;
 294   3          }
 295   2          case 0x49:
 296   2          {
 297   3          if(C0H < 4)
 298   3            i = 2;
 299   3          else if(C0H < 12)
 300   3            i = 1;
 301   3          else
 302   3            i = 0;
C51 COMPILER V9.59.0.0   MAIN                                                              03/16/2019 10:48:28 PAGE 6   

 303   3          break;
 304   3          }
 305   2        }
 306   1        SVPAngleStep = SVPNextAngleStep;
 307   1        switch(i)
 308   1        {
 309   2          default :
 310   2            T2MOD = 0x69;
 311   2            SVPNextAngleStep = 1;
 312   2          break;
 313   2          
 314   2          case 1 :
 315   2            T2MOD = 0x59;
 316   2            SVPNextAngleStep = 2;
 317   2          break;
 318   2          
 319   2          case 2 :
 320   2            T2MOD = 0x49;
 321   2            SVPNextAngleStep = 4;
 322   2          break;
 323   2        }
 324   1      }
 325          
 326          void PWM_Interrupu_Init()
 327          {
 328   1        EIE |= 0X08;
 329   1      }
 330           
 331          
 332          void UpdateSVPFreq(unsigned int n) using 3
 333          {
 334   1        T3CON &= 0XE7;
 335   1        RL3 = ~(n & 0xff);
 336   1        RH3 = ~(n >> 8);
 337   1        T3CON |= 0X08;
 338   1      }
 339          
 340          void UpdateBLDC_Dly(unsigned int n) using 3
 341          {
 342   1        T3CON &= 0XE7;
 343   1        T3CON &= 0xF8;
 344   1        T3CON |= 0X07;
 345   1        RL3 = ~(n & 0xff);
 346   1        RH3 = ~(n >> 8);
 347   1        T3CON |= 0X08;
 348   1      }
 349          
 350          void ADC_CurrentShunt_Compare_Start() using 1
 351          {
 352   1        ADCCON1 = 0X07;   
 353   1        if((CurrentElectricCycle == 1)||(CurrentElectricCycle == 2))
 354   1        {
 355   2          ADCCON0 = 0X00; // PWM0 trig
 356   2        }
 357   1        else 
 358   1        {
 359   2          if((CurrentElectricCycle == 3)||(CurrentElectricCycle == 4))
 360   2            ADCCON0 = 0X10; // PWM2 trig
 361   2          else
 362   2            ADCCON0 = 0X20; // PWM4 trig
 363   2        }
 364   1        ADCDLY = 5;
C51 COMPILER V9.59.0.0   MAIN                                                              03/16/2019 10:48:28 PAGE 7   

 365   1        ADCCON2 = 0x20; //enable fault brake
 366   1        CShunt_ADC_Interrupt = 1;
 367   1        EADC = 1;
 368   1      //  ADCCON0 |= 0X40;
 369   1      }
 370          
 371          void Input_Capture_Interrupt_ISR() interrupt 12 using 3
 372          {
 373   1        bit ripple = 0;
 374   1        CAPCON0 &= 0XFE;
 375   1        Previous2MechanicalDelay = Previous1MechanicalDelay;
 376   1        EADC = 0;
 377   1        Previous1MechanicalDelay = ((int)C0H << 8)+ C0L;
 378   1        EADC = 1;
 379   1        if(ENABLE_SVPWM_FOR_SYNCM)
 380   1        {
 381   2          if(SVPReverseSpin)
 382   2            SVPDriveAngle = ElecAngleOffestCW;
 383   2          else
 384   2            SVPDriveAngle = ElecAngleOffestCCW; 
 385   2          Previous4CaptureCnt = Previous3CaptureCnt;
 386   2          Previous3CaptureCnt = Previous2CaptureCnt;
 387   2          Previous2CaptureCnt = Previous1CaptureCnt;
 388   2          Previous1CaptureCnt = Previous1MechanicalDelay;
 389   2          if(SVP_Angle_Delay > 15)
 390   2          {
 391   3            SVP_Angle_Delay = 0;
 392   3          }
 393   2          switch(T2MOD)
 394   2          {
 395   3            case 0x49: break;
 396   3            case 0x59: Previous1MechanicalDelay <<= 1; break;
 397   3            case 0x69: Previous1MechanicalDelay <<= 2; break;
 398   3          }
 399   2          if(Previous4CaptureCnt > Previous3CaptureCnt)
 400   2          {
 401   3            if(Previous4CaptureCnt - Previous3CaptureCnt > 200)
 402   3            {
 403   4              ripple = 1;
 404   4            }
 405   3          }
 406   2          else
 407   2          {   
 408   3            if(Previous3CaptureCnt - Previous4CaptureCnt > 200)
 409   3            {
 410   4              ripple = 1;
 411   4            }
 412   3          }
 413   2          if(Previous3CaptureCnt > Previous2CaptureCnt)
 414   2          {
 415   3            if(Previous3CaptureCnt - Previous2CaptureCnt > 200)
 416   3            {
 417   4              ripple = 1;
 418   4            }
 419   3          }
 420   2          else
 421   2          {   
 422   3            if(Previous2CaptureCnt - Previous3CaptureCnt > 200)
 423   3            {
 424   4              ripple = 1;
 425   4            }
 426   3          }
C51 COMPILER V9.59.0.0   MAIN                                                              03/16/2019 10:48:28 PAGE 8   

 427   2          if(Previous2CaptureCnt > Previous1CaptureCnt)
 428   2          {
 429   3            if(Previous2CaptureCnt - Previous1CaptureCnt > 200)
 430   3            {
 431   4              ripple = 1;
 432   4            }
 433   3          }
 434   2          else
 435   2          {   
 436   3            if(Previous1CaptureCnt - Previous2CaptureCnt > 200)
 437   3            {
 438   4              ripple = 1;
 439   4            }
 440   3          }
 441   2          if(ripple)
 442   2          {
 443   3            UpdateSVPFreq(Previous1CaptureCnt); 
 444   3          }
 445   2          else
 446   2          {
 447   3            UpdateSVPFreq((Previous1CaptureCnt + Previous2CaptureCnt + Previous3CaptureCnt + Previous4CaptureCnt) >
             -> 2);  
 448   3          }
 449   2        /*  if(Previous2MechanicalDelay < Previous1MechanicalDelay)
 450   2          {
 451   2            if(ElecAngleOffestCW < 255)
 452   2            {
 453   2              ElecAngleOffestCW ++;
 454   2            }
 455   2          }
 456   2          else
 457   2          {
 458   2            if(ElecAngleOffestCW > 0)
 459   2            {
 460   2              ElecAngleOffestCW --;
 461   2            }
 462   2          }*/
 463   2          SetSpeedRange_SVPrecision();
 464   2          if((Previous1MechanicalDelay <= SpeedLowLimitforSVP) && ((Previous1MechanicalDelay >= Previous2Mechanica
             -lDelay - (Previous2MechanicalDelay >> SpeedRippleLimitforSVP)) && (Previous1MechanicalDelay <= Previous2MechanicalDelay 
             -+ (Previous2MechanicalDelay >> SpeedRippleLimitforSVP))))
 465   2          {
 466   3            if(Stablecnt >= 4)
 467   3            {
 468   4              if(ENABLE_SVPWM_FOR_SYNCM)
 469   4              {
 470   5                SVPWMmode = 1;
 471   5              }
 472   4            }
 473   3            else
 474   3              Stablecnt += 1;
 475   3          }
 476   2          else
 477   2          {
 478   3            Stablecnt = 0;
 479   3            SVPWMmode = 0;
 480   3          }
 481   2        }
 482   1      }
 483          
 484          void BLDC_SNSLess_StepXL() using 2
 485          {
C51 COMPILER V9.59.0.0   MAIN                                                              03/16/2019 10:48:28 PAGE 9   

 486   1          //30DEG delay Counting Start
 487   1          if(0)
 488   1          {
 489   2            if(CurrentElectricCycle<6)  CurrentElectricCycle+=1;
 490   2            else    
 491   2            {
 492   3              CurrentElectricCycle = 1;
 493   3            }
 494   2          }
 495   1          else
 496   1          { 
 497   2            if(CurrentElectricCycle>1)  CurrentElectricCycle-=1;
 498   2            else    
 499   2            {
 500   3              CurrentElectricCycle = 6; 
 501   3            }
 502   2          }
 503   1      }
 504          
 505          
 506          void ADC_PWM_FallEdge_BEMF_Dct() using 1
 507          {
 508   1        ADCCON2 = 0x00; //disable fault brake   
 509   1        ADCCON1 = 0X03;   //PWM fallinmg Edge trig
 510   1        if((CurrentElectricCycle == 1)||(CurrentElectricCycle == 2))
 511   1        {
 512   2          ADCCON0 = 0X00 | (0X03 + BEMF_DCT_Params[CurrentElectricCycle - 1][DC_CH]); // PWM0 trig
 513   2        }
 514   1        else 
 515   1        {
 516   2          if((CurrentElectricCycle == 3)||(CurrentElectricCycle == 4))
 517   2            ADCCON0 = 0X10 | (0X03 + BEMF_DCT_Params[CurrentElectricCycle - 1][DC_CH]); // PWM2 trig
 518   2          else
 519   2            ADCCON0 = 0X20 | (0X03 + BEMF_DCT_Params[CurrentElectricCycle - 1][DC_CH]); // PWM4 trig
 520   2        }
 521   1        ADCDLY = 20;
 522   1        CShunt_ADC_Interrupt = 0;
 523   1        EADC = 1;
 524   1      }
 525          
 526          
 527          void BLDC_StartUP_OnProcCalc() using 2
 528          {
 529   1        CurrentFrequency =  STARTUP_FREQUENCY + (UsedStartupTime / (Accelerationtime / AccelerationFrequency ) ) 
             -;
 530   1        BLDC_SNSLess_PWM = STARTUP_PWM + (UsedStartupTime / (Accelerationtime / AccelerationPWM ) ) ; 
 531   1        DelayMsBetweenCurrentElectricalCycle = 10000 /  CurrentFrequency; 
 532   1        if(UsedStartupTime == 0)
 533   1        {
 534   2          UpdateBLDC_Dly(LOCK_POSITION_TIME * 125);     
 535   2          BLDC_SNSLess_PWM = LOCK_POSITION_PWM;
 536   2        } 
 537   1        else 
 538   1        {UpdateBLDC_Dly(DelayMsBetweenCurrentElectricalCycle * 12);}    
 539   1        if((UsedStartupTime > Accelerationtime))
 540   1        {
 541   2          //startup_failed
 542   2          BLDC_Sensorless_Status = BLDC_Run;      
 543   2          T3CON &= 0XE7;    //Timer3 Stop
 544   2          SetMotorSpin(101,1);
 545   2          SetBLDCPWM(BLDC_SNSLess_PWM);   
 546   2          
C51 COMPILER V9.59.0.0   MAIN                                                              03/16/2019 10:48:28 PAGE 10  

 547   2          BLDC_SNSLess_StepXL();
 548   2          SetElecCycleU2(CurrentElectricCycle);
 549   2          UpdateBLDCInverter(); 
 550   2          if(BEMF_PWM_ON_Detect)
 551   2          {
 552   3            ADC_CurrentShunt_Compare_Start();
 553   3          }
 554   2          else
 555   2          {
 556   3            ADC_PWM_FallEdge_BEMF_Dct();
 557   3          }
 558   2          
 559   2        }
 560   1        else
 561   1          UsedStartupTime = UsedStartupTime + DelayMsBetweenCurrentElectricalCycle; 
 562   1      }
 563          
 564          void Timer3_Interr_ISR() interrupt 16 using 2
 565          { 
 566   1        T3CON &= 0XEF;  //clear timer interrupt
 567   1        if(BLDC_SENSORLESS)
 568   1        { 
 569   2          SetBLDCPWM(BLDC_SNSLess_PWM);   
 570   2          BLDC_SNSLess_StepXL();
 571   2          if(BLDC_Sensorless_Status == BLDC_Run)
 572   2          {
 573   3            T3CON &= 0XE7;    //Timer3 Stop 
 574   3          }
 575   2          SetElecCycleU2(CurrentElectricCycle);
 576   2          UpdateBLDCInverter(); 
 577   2          ADC_CurrentShunt_Compare_Start();
 578   2          
 579   2          //Calculate Startup Process
 580   2          if(BLDC_Sensorless_Status == BLDC_Startup)
 581   2          {
 582   3            BLDC_StartUP_OnProcCalc();
 583   3          }
 584   2        }
 585   1        if(ENABLE_SVPWM_FOR_SYNCM)
 586   1        {
 587   2          //These codes used only for SVPWM mode
 588   2          if(SVPDriveAngle < 255-SVPAngleStep)
 589   2            SVPDriveAngle += SVPAngleStep;
 590   2          else
 591   2          {
 592   3            SVPDriveAngle = 0;
 593   3            if(SVP_Angle_Delay < 255)
 594   3              SVP_Angle_Delay++;
 595   3          }
 596   2          CalcElectricAngle = SVPDriveAngle;
 597   2          if(SVPWMmode)
 598   2          {   
 599   3              if(SVPReverseSpin)
 600   3                CalcElectricAngle = 255 - CalcElectricAngle;
 601   3              CalculateInverterVectorsWidth_Polar(CalcElectricAngle);
 602   3          }
 603   2        }
 604   1      }
 605          
 606          void PWM_Interr_ISR() interrupt 13 using 0
 607          {
 608   1        PWMF = 0;
C51 COMPILER V9.59.0.0   MAIN                                                              03/16/2019 10:48:28 PAGE 11  

 609   1      }
 610          
 611          
 612          
 613          void ADC_Interrupt_ISR() interrupt 11 using 1
 614          {
 615   1      //  debug1 = 1;
 616   1        EADC = 0;
 617   1        ADCF = 0;
 618   1        ADCCON1 = 0X01;   //Enable ADC and Start Converting immediately
 619   1        
 620   1        
 621   1          P07 = !P07;
 622   1        
 623   1        if(CShunt_ADC_Interrupt)
 624   1        {
 625   2          Current_SENSE_ADC_Value  = (ADCRH << 4) + ADCRL;
 626   2          //  BEMF_PWM_ON_Detect
 627   2          if(BEMF_PWM_ON_Detect)
 628   2          {
 629   3            ADCCON0 = (0X03 + BEMF_DCT_Params[CurrentElectricCycle - 1][DC_CH]) | 0x40;
 630   3          }
 631   2          else
 632   2          {
 633   3            ADC_PWM_FallEdge_BEMF_Dct();
 634   3            return;
 635   3          }
 636   2          //Start ADC for DC_Volt Detection
 637   2          adcbemfreg0s = (0X03 + BEMF_DCT_Params[CurrentElectricCycle  - 1][BEMF_CH]) | 0x40 ;
 638   2          if(Adc_Smpl_Count < 1)
 639   2            Adc_Smpl_Count += 1;
 640   2          else
 641   2            Adc_Smpl_Count = 0;
 642   2          adcalterreg0s = ADC_Sample_Sequence[Adc_Smpl_Count] | 0x40 ;
 643   2          while(ADCS);
 644   2        }
 645   1        DCBUS_ADC_Value = (ADCRH << 4) + ADCRL;
 646   1        ADCCON0 = adcbemfreg0s; //Start ADC for BEMF Detection
 647   1        while(ADCS);
 648   1        
 649   1        BEMF_ADC_Value = (ADCRH << 4) + ADCRL;
 650   1        ADCCON0 = adcalterreg0s;  //Start ADC for Alternate Detection
 651   1        bcrtnv = BEMF_Calculate(CurrentElectricCycle,DCBUS_ADC_Value,BEMF_ADC_Value,BEMF_PWM_ON_Detect);
 652   1        while(ADCS);
 653   1        
 654   1        if((bcrtnv == CurrentElectricCycle)&&(BLDC_Sensorless_Status == BLDC_Run))
 655   1        {   
 656   2          SetBLDCPWM(BLDC_SNSLess_PWM);   
 657   2          BLDC_SNSLess_StepXL();
 658   2          SetElecCycleU2(CurrentElectricCycle);
 659   2          UpdateBLDCInverter(); 
 660   2        }
 661   1        ADC_CurrentShunt_Compare_Start();
 662   1      //  debug1 = 0;
 663   1      }
 664          
 665          void Set_Currrent_Limit_Threshold(unsigned int th)
 666          {
 667   1        ADCMPH = th >> 8; //current limit
 668   1        ADCMPL = th & 0xff;;
 669   1      }
 670          
C51 COMPILER V9.59.0.0   MAIN                                                              03/16/2019 10:48:28 PAGE 12  

 671          void ADCInit()
 672          {
 673   1        Set_Currrent_Limit_Threshold(0xfff);
 674   1        ADC_CurrentShunt_Compare_Start();
 675   1        EADC = 1;
 676   1      }
 677          
 678          void BLDC_SNSless_Parms_Calc()
 679          {
 680   1        Accelerationtime = ACCELERATION_TIME * 10;
 681   1        AccelerationFrequency = STARTUP_END_FREQUENCY - STARTUP_FREQUENCY;
 682   1        AccelerationPWM  = STARTUP_END_PWM - STARTUP_PWM ;
 683   1      }
 684          
 685          void main(void)
 686          {
 687   1        unsigned int i;
 688   1      //  UartInit();
 689   1        Inverter_ControlGPIO_Init();
 690   1        HallGpioInit();
 691   1        BEMF_Gpio_ADCIN_Init();
 692   1        ADCInit();
 693   1        SetMotorSpin(30,1);
 694   1        TimerInit();
 695   1        BLDC_SNSless_Parms_Calc();
 696   1        
 697   1        BLDC_Sensorless_Status = BLDC_Startup;
 698   1        
 699   1        UpdateBLDC_Dly(418);
 700   1        
 701   1      //  PWM_Interrupu_Init();
 702   1        
 703   1        
 704   1        P0M1 &= 0x7f;
 705   1        P0M2 |= 0x80;
 706   1          
 707   1        P1M1 &= 0Xb0;
 708   1        P1M2 &= 0Xb0; 
 709   1        
 710   1        debug1 = 1;
 711   1        
 712   1      //  UartSendStr("DAS02418");
 713   1        while(1)
 714   1        {
 715   2          for(i = 0;i < 254;i += 1)
 716   2          { 
 717   3            
 718   3        //  BLDCTimerEventHandler();
 719   3        //    UpdateBLDCInverter(i);
 720   3      
 721   3            //CalculateInverterVectorsWidth_Polar(i);
 722   3      /*      UART_Write_Int_Value(CalcElectricAngle);
 723   3            if(HA)
 724   3              UartSendStr("HA+");
 725   3            else  
 726   3              UartSendStr("HA-");
 727   3            
 728   3            if(HB)
 729   3              UartSendStr("HB+");
 730   3            else  
 731   3              UartSendStr("HB-");
 732   3            
C51 COMPILER V9.59.0.0   MAIN                                                              03/16/2019 10:48:28 PAGE 13  

 733   3            if(HC)
 734   3              UartSendStr("HC+");
 735   3            else  
 736   3              UartSendStr("HC-");
 737   3            switch(DetermineCurrentElecCycle(0))
 738   3            {
 739   3              case 0:
 740   3                UartSendStr("HALL ERROR\r\n"); break;
 741   3              case 1:
 742   3                UartSendStr("HALL 1\r\n");break;
 743   3              case 2:
 744   3                UartSendStr("HALL 2\r\n");break;
 745   3              case 3:
 746   3                UartSendStr("HALL 3\r\n");break;
 747   3              case 4:
 748   3                UartSendStr("HALL 4\r\n");break;
 749   3              case 5:
 750   3                UartSendStr("HALL 5\r\n");break;
 751   3              case 6:
 752   3                UartSendStr("HALL 6\r\n");break;
 753   3            }*/
 754   3          }
 755   2        }
 756   1      }
*** WARNING C294 IN LINE 489 OF main.c: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2140    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     28    ----
   PDATA SIZE       =     43    ----
   DATA SIZE        =     33       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      6       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
