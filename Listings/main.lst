C51 COMPILER V9.59.0.0   MAIN                                                              01/23/2019 17:22:28 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <N76E003.h>
   2          #include <SVPWM.h>
   3          #include <3PhaseInverter.h>
   4          #include <BLDC with Hall.h>
   5          #include "intrins.h"
   6          
   7          bit SVPWMmode = 0;
   8          bit SVPReverseSpin = 1;
   9          bit ENABLE_SVPWM_FOR_SYNCM = 1;
  10          unsigned char ElecAngleOffestCCW = 189;
  11          unsigned char StableCount = 10;
  12          unsigned char ElecAngleOffestCW = 215; // 238wm // 222
  13          unsigned char SVPAngleStep = 1;
  14          unsigned char SVPNextAngleStep = 1;
  15          unsigned char SpeedRippleLimitforSVP = 2;
  16          unsigned int SpeedLowLimitforSVP = 6000;
  17          unsigned int SatiSCyclesSwSVP = 0;
  18          unsigned char Stablecnt = 0;
  19          unsigned int SpeedCount = 0;
  20          unsigned char PrevoiusMechinalCycle = 0;
  21          unsigned int CalcElectricAngle = 0;
  22          unsigned int SVPDriveAngle = 0;
  23          unsigned char SVPWMCurPWM = 0;
  24          unsigned char ExecuteSVPBL_PWM = 0;
  25          unsigned int PulseCount = 0;
  26          unsigned char SVP_Angle_Delay = 0;
  27          unsigned int Previous1CaptureCnt,Previous2CaptureCnt,Previous3CaptureCnt,Previous4CaptureCnt;
  28          unsigned int Previous1MechanicalDelay, Previous2MechanicalDelay, CurrentElectricAngle, PreviousElectricAng
             -le;
  29          
  30          unsigned char code number[]={'0','1','2','3','4','5','6','7','8','9',}; 
  31          sbit debug1 = P0^2;
  32          
  33          #define FOSC            30000000UL
  34          #define BRT             (65536 - FOSC / 115200 / 4)
  35          
  36          bit busy;
  37          char wptr;
  38          char rptr;
  39          char buffer[16];
  40          
  41          void UartIsr() interrupt 4 using 1
  42          {
  43   1          if (TI)
  44   1          {
  45   2              TI = 0;
  46   2              busy = 0;
  47   2          }
  48   1          if (RI)
  49   1          {
  50   2              RI = 0;
  51   2              buffer[wptr++] = SBUF;
  52   2              wptr &= 0x0f;
  53   2          }
C51 COMPILER V9.59.0.0   MAIN                                                              01/23/2019 17:22:28 PAGE 2   

  54   1      }
  55          
  56          void UartInit()
  57          {
  58   1       /*   SCON = 0x50;
  59   1          T2L = BRT;
  60   1          T2H = BRT >> 8;
  61   1          AUXR = 0x15;
  62   1          wptr = 0x00;
  63   1          rptr = 0x00;
  64   1          busy = 0;*/
  65   1      }
  66          
  67          void UartSend(char dat)
  68          {
  69   1          while (busy);
  70   1          busy = 1;
  71   1          SBUF = dat;
  72   1      }
  73          
  74          void UartSendStr(char *p)
  75          {
  76   1          while (*p)
  77   1          {
  78   2              UartSend(*p++);
  79   2          }
  80   1      }
  81          
  82          
  83          void delay(unsigned long t)
  84          {
  85   1        while(t--);
  86   1      }
  87          
  88          void UART_Write_Int_Value(unsigned int num)
  89          {
  90   1        UartSend(number[num%1000/100]);
  91   1        UartSend(number[num%100/10]);
  92   1        UartSend(number[num%10]);
  93   1      }
  94          
  95          void TimerInit()
  96          {
  97   1      //  CKCON |= 0X18;
  98   1        TMOD = 0x00;   
  99   1        T2MOD = 0X69; //low speed 69 high speed 49 mid speed 59
 100   1        CAPCON0 |= 0X10;
 101   1        CAPCON1 = 0X00;
 102   1        CAPCON2 = 0X10;
 103   1      //  CAPCON3 = 0X04;
 104   1        CAPCON3 = 0X08;
 105   1        RCMP2H = 0XFF;
 106   1        RCMP2H = 0XFE;
 107   1        
 108   1        RL3 = 0X00;
 109   1        RH3 = 0XF0;
 110   1        EIE1 |= 0X02;
 111   1        T3CON &= 0XEF;
 112   1        T3CON |= 0X08;
 113   1        
 114   1        TH1 = 0x70;
 115   1        TL1 = 0x24;
C51 COMPILER V9.59.0.0   MAIN                                                              01/23/2019 17:22:28 PAGE 3   

 116   1        EIE |= 0X04;
 117   1        
 118   1        T2CON |= 0X04;
 119   1        
 120   1        EIPH |= 0X04;
 121   1        EIP &= 0XFB;
 122   1        EIP |= 0X80;
 123   1        EIPH &= 0X7F;
 124   1        
 125   1        TMOD |= 0x01; 
 126   1        TL0 = 0xAB; 
 127   1        TH0 = 0x2F;
 128   1        TF0 = 0;
 129   1        TR0 = 1;
 130   1        ET0 = 1;
 131   1        
 132   1        PICON = 0XFD;
 133   1        PINEN |= 0X58;
 134   1        PIPEN |= 0X38;
 135   1        EIE |= 0X02;
 136   1        
 137   1        EIPH |= 0X80;
 138   1        EIP |= 0X80;
 139   1        
 140   1        EIP |= 0X26;
 141   1        
 142   1        EIPH1 |= 0X02;
 143   1        
 144   1      //  TR1 = 1;     
 145   1      //  ET1 = 1;
 146   1        EA = 1;
 147   1      }
 148          
 149          void SetMotorSpin(unsigned char pwm, bit dir)
 150          {
 151   1        unsigned int blpwm;
 152   1        blpwm = pwm;
 153   1        SetBLDCDirPWM(blpwm,dir);
 154   1        SetSVPWMValue(pwm);
 155   1        SVPReverseSpin = dir;
 156   1      }
 157          
 158          
 159          void Pin_Interrupt_ISR() interrupt 7
 160          {
 161   1        if(PIF & 0x38)
 162   1        {
 163   2        }
 164   1        if(PIF & 0x40)
 165   1        {
 166   2          PIF &= 0XB0;
 167   2          if(PulseCount < 0xff)
 168   2            PulseCount++;
 169   2        }
 170   1        PIF &= 0x00;
 171   1      }
 172          
 173          void Timer0_ISR() interrupt 1
 174          {
 175   1        TR0 = 0;
 176   1        TF0 = 0;
 177   1        TL0 = 0xAB; 
C51 COMPILER V9.59.0.0   MAIN                                                              01/23/2019 17:22:28 PAGE 4   

 178   1        TH0 = 0x2F;
 179   1        PulseCount = 64;
 180   1        if(ExecuteSVPBL_PWM < PulseCount) ExecuteSVPBL_PWM++;
 181   1        if(ExecuteSVPBL_PWM > PulseCount) ExecuteSVPBL_PWM--;
 182   1      //  SetMotorSpin(ExecuteSVPBL_PWM,1);
 183   1        PulseCount = 0;
 184   1        TR0 = 1;
 185   1      }
 186          
 187          void SetSpeedRange_SVPrecision() using 1
 188          {
 189   1        unsigned char i;
 190   1        switch(T2MOD)
 191   1        {
 192   2          case 0x69:
 193   2          {
 194   3          if(C0H < 1)
 195   3            i = 2;
 196   3          else if(C0H < 4)
 197   3            i = 1;
 198   3          else
 199   3            i = 0;
 200   3          break;
 201   3          }
 202   2          case 0x59:
 203   2          {
 204   3          if(C0H < 2)
 205   3            i = 2;
 206   3          else if(C0H < 6)
 207   3            i = 1;
 208   3          else
 209   3            i = 0;
 210   3          break;
 211   3          }
 212   2          case 0x49:
 213   2          {
 214   3          if(C0H < 4)
 215   3            i = 2;
 216   3          else if(C0H < 12)
 217   3            i = 1;
 218   3          else
 219   3            i = 0;
 220   3          break;
 221   3          }
 222   2        }
 223   1        SVPAngleStep = SVPNextAngleStep;
 224   1        switch(i)
 225   1        {
 226   2          default :
 227   2            T2MOD = 0x69;
 228   2            SVPNextAngleStep = 1;
 229   2          break;
 230   2          
 231   2          case 1 :
 232   2            T2MOD = 0x59;
 233   2            SVPNextAngleStep = 2;
 234   2          break;
 235   2          
 236   2          case 2 :
 237   2            T2MOD = 0x49;
 238   2            SVPNextAngleStep = 4;
 239   2          break;
C51 COMPILER V9.59.0.0   MAIN                                                              01/23/2019 17:22:28 PAGE 5   

 240   2        }
 241   1      }
 242          
 243          void PWM_Interrupu_Init()
 244          {
 245   1        EIE |= 0X08;
 246   1      }
 247           
 248          
 249          void UpdateSVPFreq(unsigned int n) using 3
 250          {
 251   1        T3CON &= 0XE7;
 252   1        RL3 = ~(n & 0xff);
 253   1        RH3 = ~(n >> 8);
 254   1        T3CON |= 0X08;
 255   1      }
 256          
 257          
 258          void Input_Capture_Interrupt_ISR() interrupt 12 using 3
 259          {
 260   1        bit ripple = 0;
 261   1        CAPCON0 &= 0XFE;
 262   1        if(SVPReverseSpin)
 263   1          SVPDriveAngle = ElecAngleOffestCW;
 264   1        else
 265   1          SVPDriveAngle = ElecAngleOffestCCW; 
 266   1        Previous2MechanicalDelay = Previous1MechanicalDelay;
 267   1        Previous1MechanicalDelay = ((int)C0H << 8)+ C0L;
 268   1        Previous4CaptureCnt = Previous3CaptureCnt;
 269   1        Previous3CaptureCnt = Previous2CaptureCnt;
 270   1        Previous2CaptureCnt = Previous1CaptureCnt;
 271   1        Previous1CaptureCnt = Previous1MechanicalDelay;
 272   1        if(SVP_Angle_Delay > 15)
 273   1        {
 274   2        //  ElecAngleOffestCW++;
 275   2          SVP_Angle_Delay = 0;
 276   2        }
 277   1        switch(T2MOD)
 278   1        {
 279   2          case 0x49: break;
 280   2          case 0x59: Previous1MechanicalDelay <<= 1; break;
 281   2          case 0x69: Previous1MechanicalDelay <<= 2; break;
 282   2        }
 283   1        if(Previous4CaptureCnt > Previous3CaptureCnt)
 284   1        {
 285   2          if(Previous4CaptureCnt - Previous3CaptureCnt > 200)
 286   2          {
 287   3            ripple = 1;
 288   3          }
 289   2        }
 290   1        else
 291   1        {   
 292   2          if(Previous3CaptureCnt - Previous4CaptureCnt > 200)
 293   2          {
 294   3            ripple = 1;
 295   3          }
 296   2        }
 297   1        if(Previous3CaptureCnt > Previous2CaptureCnt)
 298   1        {
 299   2          if(Previous3CaptureCnt - Previous2CaptureCnt > 200)
 300   2          {
 301   3            ripple = 1;
C51 COMPILER V9.59.0.0   MAIN                                                              01/23/2019 17:22:28 PAGE 6   

 302   3          }
 303   2        }
 304   1        else
 305   1        {   
 306   2          if(Previous2CaptureCnt - Previous3CaptureCnt > 200)
 307   2          {
 308   3            ripple = 1;
 309   3          }
 310   2        }
 311   1        if(Previous2CaptureCnt > Previous1CaptureCnt)
 312   1        {
 313   2          if(Previous2CaptureCnt - Previous1CaptureCnt > 200)
 314   2          {
 315   3            ripple = 1;
 316   3          }
 317   2        }
 318   1        else
 319   1        {   
 320   2          if(Previous1CaptureCnt - Previous2CaptureCnt > 200)
 321   2          {
 322   3            ripple = 1;
 323   3          }
 324   2        }
 325   1        if(ripple)
 326   1        {
 327   2          UpdateSVPFreq(Previous1CaptureCnt); 
 328   2        }
 329   1        else
 330   1        {
 331   2          UpdateSVPFreq((Previous1CaptureCnt + Previous2CaptureCnt + Previous3CaptureCnt + Previous4CaptureCnt) >>
             - 2);  
 332   2        }
 333   1      /*  if(Previous2MechanicalDelay < Previous1MechanicalDelay)
 334   1        {
 335   1          if(ElecAngleOffestCW < 255)
 336   1          {
 337   1            ElecAngleOffestCW ++;
 338   1          }
 339   1        }
 340   1        else
 341   1        {
 342   1          if(ElecAngleOffestCW > 0)
 343   1          {
 344   1            ElecAngleOffestCW --;
 345   1          }
 346   1        }*/
 347   1        SetSpeedRange_SVPrecision();
 348   1        if((Previous1MechanicalDelay <= SpeedLowLimitforSVP) && ((Previous1MechanicalDelay >= Previous2Mechanical
             -Delay - (Previous2MechanicalDelay >> SpeedRippleLimitforSVP)) && (Previous1MechanicalDelay <= Previous2MechanicalDelay +
             - (Previous2MechanicalDelay >> SpeedRippleLimitforSVP))))
 349   1        {
 350   2          if(Stablecnt >= 4)
 351   2          {
 352   3            if(ENABLE_SVPWM_FOR_SYNCM)
 353   3            {
 354   4              SVPWMmode = 1;
 355   4            }
 356   3          }
 357   2          else
 358   2            Stablecnt += 1;
 359   2        }
 360   1        else
C51 COMPILER V9.59.0.0   MAIN                                                              01/23/2019 17:22:28 PAGE 7   

 361   1        {
 362   2          Stablecnt = 0;
 363   2          SVPWMmode = 0;
 364   2        }
 365   1      }
 366          
 367          void Timer3_Interr_ISR() interrupt 16 using 1
 368          { 
 369   1        T3CON &= 0XEF;
 370   1        if(SVPDriveAngle < 255-SVPAngleStep)
 371   1          SVPDriveAngle += SVPAngleStep;
 372   1        else
 373   1        {
 374   2          SVPDriveAngle = 0;
 375   2          if(SVP_Angle_Delay < 255)
 376   2            SVP_Angle_Delay++;
 377   2        }
 378   1        CalcElectricAngle = SVPDriveAngle;
 379   1        if(SVPWMmode)
 380   1        {   
 381   2            if(SVPReverseSpin)
 382   2              CalcElectricAngle = 255 - CalcElectricAngle;
 383   2            CalculateInverterVectorsWidth_Polar(CalcElectricAngle);
 384   2        }
 385   1        else
 386   1        {
 387   2          BLDCTimerEventHandler();
 388   2        }
 389   1      }
 390          
 391          void PWM_Interr_ISR() interrupt 13 using 2
 392          {
 393   1        PWMF = 0;
 394   1        ADCCON0 |= 0X40;
 395   1      }
 396          
 397          
 398          void ADCInit()
 399          {
 400   1        ADCCON0 = 0X04;
 401   1        ADCCON1 = 0X07;
 402   1        ADCMPH = 0XA0; //current limit
 403   1        ADCMPL = 0x00;
 404   1        ADCDLY = 28;
 405   1        ADCCON2 = 0xa0;
 406   1      }
 407          
 408          void main(void)
 409          {
 410   1        unsigned int i;
 411   1      //  UartInit();
 412   1      //  ES = 1;
 413   1      //  EA = 1;
 414   1        Inverter_ControlGPIO_Init();
 415   1        HallGpioInit();
 416   1        ADCInit();
 417   1        SetMotorSpin(40,1);
 418   1        TimerInit();
 419   1      //  PWM_Interrupu_Init();
 420   1        
 421   1        P0M1 &= 0xfb;
 422   1        P0M2 |= 0x04;
C51 COMPILER V9.59.0.0   MAIN                                                              01/23/2019 17:22:28 PAGE 8   

 423   1          
 424   1        P1M1 &= 0Xb0;
 425   1        P1M2 &= 0Xb0; 
 426   1        
 427   1        debug1 = 1;
 428   1        
 429   1      //  UartSendStr("DAS02418");
 430   1        while(1)
 431   1        {
 432   2          for(i = 0;i < 254;i += 1)
 433   2          { 
 434   3            
 435   3        //  BLDCTimerEventHandler();
 436   3        //    UpdateBLDCInverter(i);
 437   3            delay(254);
 438   3      
 439   3            //CalculateInverterVectorsWidth_Polar(i);
 440   3      /*      UART_Write_Int_Value(CalcElectricAngle);
 441   3            if(HA)
 442   3              UartSendStr("HA+");
 443   3            else  
 444   3              UartSendStr("HA-");
 445   3            
 446   3            if(HB)
 447   3              UartSendStr("HB+");
 448   3            else  
 449   3              UartSendStr("HB-");
 450   3            
 451   3            if(HC)
 452   3              UartSendStr("HC+");
 453   3            else  
 454   3              UartSendStr("HC-");
 455   3            switch(DetermineCurrentElecCycle(0))
 456   3            {
 457   3              case 0:
 458   3                UartSendStr("HALL ERROR\r\n"); break;
 459   3              case 1:
 460   3                UartSendStr("HALL 1\r\n");break;
 461   3              case 2:
 462   3                UartSendStr("HALL 2\r\n");break;
 463   3              case 3:
 464   3                UartSendStr("HALL 3\r\n");break;
 465   3              case 4:
 466   3                UartSendStr("HALL 4\r\n");break;
 467   3              case 5:
 468   3                UartSendStr("HALL 5\r\n");break;
 469   3              case 6:
 470   3                UartSendStr("HALL 6\r\n");break;
 471   3            }*/
 472   3          }
 473   2        }
 474   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1231    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     57       8
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4       2
C51 COMPILER V9.59.0.0   MAIN                                                              01/23/2019 17:22:28 PAGE 9   

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
