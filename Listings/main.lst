C51 COMPILER V9.59.0.0   MAIN                                                              02/23/2019 10:47:23 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <N76E003.h>
   2          #include <SVPWM.h>
   3          #include <3PhaseInverter.h>
   4          #include <BLDC with Hall.h>
   5          #include <BLDC_Sensorless.h>
   6          #include "intrins.h"
   7          //#include "NTC.c"
   8          
   9          bit SVPWMmode = 0;
  10          bit SVPReverseSpin = 1;
  11          bit ENABLE_SVPWM_FOR_SYNCM = 0;
  12          unsigned char ElecAngleOffestCCW = 189;
  13          unsigned char StableCount = 10;
  14          unsigned char ElecAngleOffestCW = 215; // 238wm // 222
  15          unsigned char SVPAngleStep = 1;
  16          unsigned char SVPNextAngleStep = 1;
  17          unsigned char SpeedRippleLimitforSVP = 2;
  18          unsigned int pdata SpeedLowLimitforSVP = 6000;
  19          unsigned int pdata SatiSCyclesSwSVP = 0;
  20          unsigned char pdata Stablecnt = 0;
  21          unsigned int pdata SpeedCount = 0;
  22          unsigned char pdata PrevoiusMechinalCycle = 0;
  23          unsigned int CalcElectricAngle = 0;
  24          unsigned int SVPDriveAngle = 0;
  25          unsigned char SVPWMCurPWM = 0;
  26          unsigned char xdata ExecuteSVPBL_PWM = 0;
  27          unsigned int pdata PulseCount = 0;
  28          unsigned char SVP_Angle_Delay = 0;
  29          unsigned int pdata Previous1CaptureCnt,Previous2CaptureCnt,Previous3CaptureCnt,Previous4CaptureCnt;
  30          unsigned int pdata Previous1MechanicalDelay, Previous2MechanicalDelay, CurrentElectricAngle, PreviousElect
             -ricAngle;
  31          unsigned int External_Analog_ADC_Value = 0;
  32          unsigned int Current_SENSE_ADC_Value = 0;
  33          unsigned char pdata CurrentElectricCycle = 0;
  34          unsigned char ADC_SampleTimes = 0;
  35          
  36          unsigned char DC_Volt_ADC_Channel = 0;
  37          unsigned char BEMF_Volt_ADC_Channel = 0;
  38          
  39          bit ADC_ISR_first_time = 0;
  40          //unsigned int NTC_ADC_Value;
  41          
  42          #define DC_VOLTAGE_SMPL 0
  43          #define BEMF_SMPL       1
  44          #define NTC_ADC         2 
  45          #define DC_VOLTAGE_SMPL 3
*** WARNING C317 IN LINE 45 OF main.c: attempt to redefine macro 'DC_VOLTAGE_SMPL'
  46          #define BEMF_SMPL       4
*** WARNING C317 IN LINE 46 OF main.c: attempt to redefine macro 'BEMF_SMPL'
  47          #define EXTERNAL_ANALOG 5 
  48          
  49          unsigned char code ADC_Sample_Sequence[]=
  50          {
  51          DC_VOLTAGE_SMPL ,
C51 COMPILER V9.59.0.0   MAIN                                                              02/23/2019 10:47:23 PAGE 2   

  52          BEMF_SMPL       ,
  53          NTC_ADC         , 
  54          DC_VOLTAGE_SMPL ,
  55          BEMF_SMPL       ,
  56          EXTERNAL_ANALOG , 
  57          };
  58          
  59          unsigned char code number[]={'0','1','2','3','4','5','6','7','8','9',}; 
  60          sbit debug1 = P0^7;
  61          
  62          #define FOSC            30000000UL
  63          #define BRT             (65536 - FOSC / 115200 / 4)
  64          
  65          bit busy;
  66          char wptr;
  67          char rptr;
  68          char buffer[16];
  69          
  70          void UartIsr() interrupt 4 using 1
  71          {
  72   1          if (TI)
  73   1          {
  74   2              TI = 0;
  75   2              busy = 0;
  76   2          }
  77   1          if (RI)
  78   1          {
  79   2              RI = 0;
  80   2              buffer[wptr++] = SBUF;
  81   2              wptr &= 0x0f;
  82   2          }
  83   1      }
  84          
  85          void UartInit()
  86          {
  87   1       /*   SCON = 0x50;
  88   1          T2L = BRT;
  89   1          T2H = BRT >> 8;
  90   1          AUXR = 0x15;
  91   1          wptr = 0x00;
  92   1          rptr = 0x00;
  93   1          busy = 0;*/
  94   1      }
  95          
  96          void UartSend(char dat)
  97          {
  98   1          while (busy);
  99   1          busy = 1;
 100   1          SBUF = dat;
 101   1      }
 102          
 103          void UartSendStr(char *p)
 104          {
 105   1          while (*p)
 106   1          {
 107   2              UartSend(*p++);
 108   2          }
 109   1      }
 110          
 111          
 112          void delay(unsigned long t)
 113          {
C51 COMPILER V9.59.0.0   MAIN                                                              02/23/2019 10:47:23 PAGE 3   

 114   1        while(t--);
 115   1      }
 116          
 117          void UART_Write_Int_Value(unsigned int num)
 118          {
 119   1        UartSend(number[num%1000/100]);
 120   1        UartSend(number[num%100/10]);
 121   1        UartSend(number[num%10]);
 122   1      }
 123          
 124          void TimerInit()
 125          {
 126   1      //  CKCON |= 0X18;
 127   1        TMOD = 0x00;   
 128   1        T2MOD = 0X69; //low speed 69 high speed 49 mid speed 59
 129   1        CAPCON0 |= 0X10;
 130   1        CAPCON1 = 0X00;
 131   1        CAPCON2 = 0X10;
 132   1      //  CAPCON3 = 0X04;
 133   1        CAPCON3 = 0X08;
 134   1        RCMP2H = 0XFF;
 135   1        RCMP2H = 0XFE;
 136   1        
 137   1        RL3 = 0X00;
 138   1        RH3 = 0XF0;
 139   1        EIE1 |= 0X02;
 140   1        T3CON &= 0XEF;
 141   1        T3CON |= 0X08;
 142   1        
 143   1        TH1 = 0x70;
 144   1        TL1 = 0x24;
 145   1        EIE |= 0X04;
 146   1        
 147   1        T2CON |= 0X04;
 148   1        
 149   1        EIPH |= 0X04;
 150   1        EIP &= 0XFB;
 151   1        EIP |= 0X80;
 152   1        EIPH &= 0X7F;
 153   1        
 154   1        TMOD |= 0x01; 
 155   1        TL0 = 0xAB; 
 156   1        TH0 = 0x2F;
 157   1        TF0 = 0;
 158   1        TR0 = 1;
 159   1        ET0 = 1;
 160   1        
 161   1        PICON = 0XFD;
 162   1        PINEN |= 0X58;
 163   1        PIPEN |= 0X38;
 164   1        
 165   1        IP |= 0x40;
 166   1        IPH |= 0x40;
 167   1        
 168   1        EIE |= 0X02;
 169   1        
 170   1        EIPH |= 0X80;
 171   1        EIP |= 0X80;
 172   1        
 173   1        EIP |= 0X26;
 174   1        
 175   1        EIPH1 |= 0X02;
C51 COMPILER V9.59.0.0   MAIN                                                              02/23/2019 10:47:23 PAGE 4   

 176   1        
 177   1      //  TR1 = 1;     
 178   1      //  ET1 = 1;
 179   1        EA = 1;
 180   1      }
 181          
 182          void SetMotorSpin(unsigned char pwm, bit dir)
 183          {
 184   1        unsigned int blpwm;
 185   1        blpwm = pwm;
 186   1        SetBLDCDirPWM(blpwm,dir);
 187   1        SetSVPWMValue(pwm);
 188   1        SVPReverseSpin = dir;
 189   1      }
 190          
 191          
 192          void Pin_Interrupt_ISR() interrupt 7
 193          {
 194   1        if(PIF & 0x38)
 195   1        {
 196   2        }
 197   1        if(PIF & 0x40)
 198   1        {
 199   2          PIF &= 0XB0;
 200   2          if(PulseCount < 0xff)
 201   2            PulseCount++;
 202   2        }
 203   1        PIF &= 0x00;
 204   1      }
 205          
 206          void Timer0_ISR() interrupt 1
 207          {
 208   1        TR0 = 0;
 209   1        TF0 = 0;
 210   1        TL0 = 0xAB; 
 211   1        TH0 = 0x2F;
 212   1        PulseCount = 64;
 213   1        if(ExecuteSVPBL_PWM < PulseCount) ExecuteSVPBL_PWM++;
 214   1        if(ExecuteSVPBL_PWM > PulseCount) ExecuteSVPBL_PWM--;
 215   1      //  SetMotorSpin(ExecuteSVPBL_PWM,1);
 216   1        PulseCount = 0;
 217   1        TR0 = 1;
 218   1      }
 219          
 220          void SetSpeedRange_SVPrecision() using 1
 221          {
 222   1        unsigned char i;
 223   1        switch(T2MOD)
 224   1        {
 225   2          case 0x69:
 226   2          {
 227   3          if(C0H < 1)
 228   3            i = 2;
 229   3          else if(C0H < 4)
 230   3            i = 1;
 231   3          else
 232   3            i = 0;
 233   3          break;
 234   3          }
 235   2          case 0x59:
 236   2          {
 237   3          if(C0H < 2)
C51 COMPILER V9.59.0.0   MAIN                                                              02/23/2019 10:47:23 PAGE 5   

 238   3            i = 2;
 239   3          else if(C0H < 6)
 240   3            i = 1;
 241   3          else
 242   3            i = 0;
 243   3          break;
 244   3          }
 245   2          case 0x49:
 246   2          {
 247   3          if(C0H < 4)
 248   3            i = 2;
 249   3          else if(C0H < 12)
 250   3            i = 1;
 251   3          else
 252   3            i = 0;
 253   3          break;
 254   3          }
 255   2        }
 256   1        SVPAngleStep = SVPNextAngleStep;
 257   1        switch(i)
 258   1        {
 259   2          default :
 260   2            T2MOD = 0x69;
 261   2            SVPNextAngleStep = 1;
 262   2          break;
 263   2          
 264   2          case 1 :
 265   2            T2MOD = 0x59;
 266   2            SVPNextAngleStep = 2;
 267   2          break;
 268   2          
 269   2          case 2 :
 270   2            T2MOD = 0x49;
 271   2            SVPNextAngleStep = 4;
 272   2          break;
 273   2        }
 274   1      }
 275          
 276          void PWM_Interrupu_Init()
 277          {
 278   1        EIE |= 0X08;
 279   1      }
 280           
 281          
 282          void UpdateSVPFreq(unsigned int n) using 3
 283          {
 284   1        T3CON &= 0XE7;
 285   1        RL3 = ~(n & 0xff);
 286   1        RH3 = ~(n >> 8);
 287   1        T3CON |= 0X08;
 288   1      }
 289          
 290          
 291          void Input_Capture_Interrupt_ISR() interrupt 12 using 3
 292          {
 293   1        bit ripple = 0;
 294   1        CAPCON0 &= 0XFE;
 295   1        if(SVPReverseSpin)
 296   1          SVPDriveAngle = ElecAngleOffestCW;
 297   1        else
 298   1          SVPDriveAngle = ElecAngleOffestCCW; 
 299   1        Previous2MechanicalDelay = Previous1MechanicalDelay;
C51 COMPILER V9.59.0.0   MAIN                                                              02/23/2019 10:47:23 PAGE 6   

 300   1        Previous1MechanicalDelay = ((int)C0H << 8)+ C0L;
 301   1        Previous4CaptureCnt = Previous3CaptureCnt;
 302   1        Previous3CaptureCnt = Previous2CaptureCnt;
 303   1        Previous2CaptureCnt = Previous1CaptureCnt;
 304   1        Previous1CaptureCnt = Previous1MechanicalDelay;
 305   1        if(SVP_Angle_Delay > 15)
 306   1        {
 307   2        //  ElecAngleOffestCW++;
 308   2          SVP_Angle_Delay = 0;
 309   2        }
 310   1        switch(T2MOD)
 311   1        {
 312   2          case 0x49: break;
 313   2          case 0x59: Previous1MechanicalDelay <<= 1; break;
 314   2          case 0x69: Previous1MechanicalDelay <<= 2; break;
 315   2        }
 316   1        if(Previous4CaptureCnt > Previous3CaptureCnt)
 317   1        {
 318   2          if(Previous4CaptureCnt - Previous3CaptureCnt > 200)
 319   2          {
 320   3            ripple = 1;
 321   3          }
 322   2        }
 323   1        else
 324   1        {   
 325   2          if(Previous3CaptureCnt - Previous4CaptureCnt > 200)
 326   2          {
 327   3            ripple = 1;
 328   3          }
 329   2        }
 330   1        if(Previous3CaptureCnt > Previous2CaptureCnt)
 331   1        {
 332   2          if(Previous3CaptureCnt - Previous2CaptureCnt > 200)
 333   2          {
 334   3            ripple = 1;
 335   3          }
 336   2        }
 337   1        else
 338   1        {   
 339   2          if(Previous2CaptureCnt - Previous3CaptureCnt > 200)
 340   2          {
 341   3            ripple = 1;
 342   3          }
 343   2        }
 344   1        if(Previous2CaptureCnt > Previous1CaptureCnt)
 345   1        {
 346   2          if(Previous2CaptureCnt - Previous1CaptureCnt > 200)
 347   2          {
 348   3            ripple = 1;
 349   3          }
 350   2        }
 351   1        else
 352   1        {   
 353   2          if(Previous1CaptureCnt - Previous2CaptureCnt > 200)
 354   2          {
 355   3            ripple = 1;
 356   3          }
 357   2        }
 358   1        if(ripple)
 359   1        {
 360   2          UpdateSVPFreq(Previous1CaptureCnt); 
 361   2        }
C51 COMPILER V9.59.0.0   MAIN                                                              02/23/2019 10:47:23 PAGE 7   

 362   1        else
 363   1        {
 364   2          UpdateSVPFreq((Previous1CaptureCnt + Previous2CaptureCnt + Previous3CaptureCnt + Previous4CaptureCnt) >>
             - 2);  
 365   2        }
 366   1      /*  if(Previous2MechanicalDelay < Previous1MechanicalDelay)
 367   1        {
 368   1          if(ElecAngleOffestCW < 255)
 369   1          {
 370   1            ElecAngleOffestCW ++;
 371   1          }
 372   1        }
 373   1        else
 374   1        {
 375   1          if(ElecAngleOffestCW > 0)
 376   1          {
 377   1            ElecAngleOffestCW --;
 378   1          }
 379   1        }*/
 380   1        SetSpeedRange_SVPrecision();
 381   1        if((Previous1MechanicalDelay <= SpeedLowLimitforSVP) && ((Previous1MechanicalDelay >= Previous2Mechanical
             -Delay - (Previous2MechanicalDelay >> SpeedRippleLimitforSVP)) && (Previous1MechanicalDelay <= Previous2MechanicalDelay +
             - (Previous2MechanicalDelay >> SpeedRippleLimitforSVP))))
 382   1        {
 383   2          if(Stablecnt >= 4)
 384   2          {
 385   3            if(ENABLE_SVPWM_FOR_SYNCM)
 386   3            {
 387   4              SVPWMmode = 1;
 388   4            }
 389   3          }
 390   2          else
 391   2            Stablecnt += 1;
 392   2        }
 393   1        else
 394   1        {
 395   2          Stablecnt = 0;
 396   2          SVPWMmode = 0;
 397   2        }
 398   1      }
 399          
 400          void Timer3_Interr_ISR() interrupt 16 using 1
 401          { 
 402   1        T3CON &= 0XEF;
 403   1        if(SVPDriveAngle < 255-SVPAngleStep)
 404   1          SVPDriveAngle += SVPAngleStep;
 405   1        else
 406   1        {
 407   2          SVPDriveAngle = 0;
 408   2          if(SVP_Angle_Delay < 255)
 409   2            SVP_Angle_Delay++;
 410   2        }
 411   1        CalcElectricAngle = SVPDriveAngle;
 412   1        if(SVPWMmode)
 413   1        {   
 414   2            if(SVPReverseSpin)
 415   2              CalcElectricAngle = 255 - CalcElectricAngle;
 416   2            CalculateInverterVectorsWidth_Polar(CalcElectricAngle);
 417   2        }
 418   1        else
 419   1        {
 420   2          CurrentElectricCycle = DetermineCurrentElecCycle(GetBLDCDirection());
C51 COMPILER V9.59.0.0   MAIN                                                              02/23/2019 10:47:23 PAGE 8   

*** WARNING C206 IN LINE 420 OF main.c: 'GetBLDCDirection': missing function-prototype
 421   2          UpdateBLDCInverter(CurrentElectricCycle);
 422   2        }
 423   1      }
 424          
 425          void PWM_Interr_ISR() interrupt 13 using 2
 426          {
 427   1        PWMF = 0;
 428   1      }
 429          
 430          void ADC_CurrentShunt_Compare_Start() using 3
 431          {
 432   1        ADCCON0 = 0X01;
 433   1        ADCCON1 = 0X07;
 434   1        ADCDLY = 5;
 435   1        ADCCON2 = 0x20; //enable fault brake
 436   1      //  ADCCON0 |= 0X40;
 437   1      }
 438          
 439          void ADC_Interrupt_ISR() interrupt 11 using 3
 440          {
 441   1        ADCF = 0;
 442   1      //  debug1 = !debug1;
 443   1        switch(ADCCON0 & 0X07)
 444   1        {
 445   2          case 0:
 446   2          {
 447   3      //      NTC_ADC_Value = ADCRH << 4 + ADCRL;
 448   3            break;   //temperature adc
 449   3          }
 450   2          case 1:
 451   2          {
 452   3            Current_SENSE_ADC_Value = ADCRH << 4 + ADCRL;
 453   3            ADC_ISR_first_time = 1;
 454   3            break;  //current sense adc
 455   3          }
 456   2          case 2:
 457   2          {
 458   3            External_Analog_ADC_Value = ADCRH << 4 + ADCRL;
 459   3            break;  //external analog input
 460   3          }
 461   2          case 3:
 462   2          {
 463   3            Set_Phase_U_Voltage_ADC_Value(ADCRH << 4 + ADCRL);
 464   3            break;  //bemf w channel
 465   3          }
 466   2          case 4:   
 467   2          {
 468   3            Set_Phase_V_Voltage_ADC_Value(ADCRH << 4 + ADCRL);
 469   3            break;  //bemf v channel
 470   3          }
 471   2          case 5:
 472   2          {
 473   3            Set_Phase_W_Voltage_ADC_Value(ADCRH << 4 + ADCRL);
 474   3            break;  //bemf u channel
 475   3          }
 476   2        } 
 477   1        if(ADC_ISR_first_time)
 478   1        {   
 479   2          switch(ADC_Sample_Sequence[ADC_SampleTimes])
 480   2          {
 481   3            case DC_VOLTAGE_SMPL:
C51 COMPILER V9.59.0.0   MAIN                                                              02/23/2019 10:47:23 PAGE 9   

 482   3            {
 483   4              Determine_BEMF_Detect_Channel(CurrentElectricCycle,1);
 484   4              break;
 485   4            }
 486   3            case BEMF_SMPL:
 487   3            {   
 488   4              Determine_BEMF_Detect_Channel(CurrentElectricCycle,2);
 489   4              Determine_BEMF_Detect_Channel(CurrentElectricCycle,3);
 490   4              break;
 491   4            }
 492   3            case NTC_ADC:
 493   3            {
 494   4                ADCCON0 = 0;
 495   4                ADCCON1 = 0X01;////
 496   4                ADCDLY = 0;
 497   4                ADCCON2 = 0x00;
 498   4                ADCCON0 |= 0X40;  //start adc
 499   4              break;
 500   4            }
 501   3            case EXTERNAL_ANALOG:
 502   3            {
 503   4                ADCCON0 = 2;
 504   4                ADCCON1 = 0X01;////
 505   4                ADCDLY = 0;
 506   4                ADCCON2 = 0x00;
 507   4                ADCCON0 |= 0X40;  //start adc
 508   4              break;
 509   4            }
 510   3          }
 511   2        
 512   2          ADC_ISR_first_time = 0;
 513   2        }
 514   1        else
 515   1        {
 516   2          ADC_CurrentShunt_Compare_Start();
 517   2        }
 518   1      //  debug1 = !debug1; 
 519   1        if(ADC_SampleTimes >= 5)
 520   1        {
 521   2            ADC_SampleTimes = 0;
 522   2        }
 523   1        ADC_SampleTimes += 1;
 524   1      }
 525          
 526          void Set_Currrent_Limit_Threshold(unsigned int th)
 527          {
 528   1        ADCMPH = th >> 8; //current limit
 529   1        ADCMPL = th & 0xff;;
 530   1      }
 531          
 532          void ADCInit()
 533          {
 534   1        Set_Currrent_Limit_Threshold(0xfff);
 535   1        ADC_CurrentShunt_Compare_Start();
 536   1        EADC = 1;
 537   1      }
 538          
 539          void main(void)
 540          {
 541   1        unsigned int i;
 542   1      //  UartInit();
 543   1      //  ES = 1;
C51 COMPILER V9.59.0.0   MAIN                                                              02/23/2019 10:47:23 PAGE 10  

 544   1      //  EA = 1;
 545   1        Inverter_ControlGPIO_Init();
 546   1        HallGpioInit();
 547   1        BEMF_Gpio_ADCIN_Init();
 548   1        ADCInit();
 549   1        SetMotorSpin(230,1);
 550   1        TimerInit();
 551   1      //  PWM_Interrupu_Init();
 552   1        
 553   1        P0M1 &= 0x7f;
 554   1        P0M2 |= 0x80;
 555   1          
 556   1        P1M1 &= 0Xb0;
 557   1        P1M2 &= 0Xb0; 
 558   1        
 559   1        debug1 = 1;
 560   1        
 561   1      //  UartSendStr("DAS02418");
 562   1        while(1)
 563   1        {
 564   2          for(i = 0;i < 254;i += 1)
 565   2          { 
 566   3            
 567   3        //  BLDCTimerEventHandler();
 568   3        //    UpdateBLDCInverter(i);
 569   3            delay(254);
 570   3      
 571   3            //CalculateInverterVectorsWidth_Polar(i);
 572   3      /*      UART_Write_Int_Value(CalcElectricAngle);
 573   3            if(HA)
 574   3              UartSendStr("HA+");
 575   3            else  
 576   3              UartSendStr("HA-");
 577   3            
 578   3            if(HB)
 579   3              UartSendStr("HB+");
 580   3            else  
 581   3              UartSendStr("HB-");
 582   3            
 583   3            if(HC)
 584   3              UartSendStr("HC+");
 585   3            else  
 586   3              UartSendStr("HC-");
 587   3            switch(DetermineCurrentElecCycle(0))
 588   3            {
 589   3              case 0:
 590   3                UartSendStr("HALL ERROR\r\n"); break;
 591   3              case 1:
 592   3                UartSendStr("HALL 1\r\n");break;
 593   3              case 2:
 594   3                UartSendStr("HALL 2\r\n");break;
 595   3              case 3:
 596   3                UartSendStr("HALL 3\r\n");break;
 597   3              case 4:
 598   3                UartSendStr("HALL 4\r\n");break;
 599   3              case 5:
 600   3                UartSendStr("HALL 5\r\n");break;
 601   3              case 6:
 602   3                UartSendStr("HALL 6\r\n");break;
 603   3            }*/
 604   3          }
 605   2        }
C51 COMPILER V9.59.0.0   MAIN                                                              02/23/2019 10:47:23 PAGE 11  

 606   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1708    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =      1    ----
   PDATA SIZE       =     27    ----
   DATA SIZE        =     37       8
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  3 WARNING(S),  0 ERROR(S)
