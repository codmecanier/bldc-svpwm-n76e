C51 COMPILER V9.59.0.0   BLDC_SENSORLESS                                                   03/16/2019 10:51:47 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE BLDC_SENSORLESS
OBJECT MODULE PLACED IN .\Objects\BLDC_Sensorless.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE BLDC_Sensorless.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Li
                    -stings\BLDC_Sensorless.lst) TABS(2) OBJECT(.\Objects\BLDC_Sensorless.obj)

line level    source

   1          #include <N76E003.h>
   2          #include <BLDC_Sensorless.h>
   3          
   4          #define MagDecayPulseDct 3    //Magnent Decay Detect threshold
   5          #define MagDecayPulseCnt 2    //Maagnent Decay Detect Count
   6          
   7          #define PhaseSwitchCount 5
   8          
   9          unsigned int data Prev_bemf;
  10          
  11          unsigned char data Last_Rtn = 0;
  12          
  13          bit Zero_Cross_Flag = 0;
  14          
  15          unsigned char data PreviousBEMF_CH;
  16          unsigned char data BEMF_Slope_Count;
  17          unsigned int data Switch_Count = 0;
  18          unsigned int data Zero_Cross_Count = 0;
  19          unsigned int pdata Period_Count = 0;
  20          
  21          const unsigned char BEMF_DCT_Params1[6][3] = {
  22            {0,2,0},
  23            {0,1,1},
  24            {1,0,0},
  25            {1,2,1},
  26            {2,1,0},
  27            {2,0,1},
  28          };
  29          
  30          /*
  31          void Start_BEMF_Detect_ADC(unsigned char eleccycle, unsigned char times, bit pwm_on_sense) using 1
  32          {
  33            if(pwm_on_sense)
  34              ADCCON1 = 0X01;
  35            else
  36              ADCCON1 = 0X03;
  37            ADCCON0 &= 0XF0;
  38            eleccycle -= 1;
  39            if(times == 1)
  40              ADCCON0 |= 0X03 + BEMF_DCT_Params1[eleccycle][DC_CH];
  41            else
  42              ADCCON0 |= 0X03 + BEMF_DCT_Params1[eleccycle][BEMF_CH];
  43            ADCDLY = 0;
  44            ADCCON2 = 0x00;
  45            if(pwm_on_sense)
  46              ADCCON0 |= 0X40;  //start adc
  47          } */
  48          
  49          /*
  50          unsigned char BEMF_Calculate(unsigned char eleccycle) using 1
  51          { 
  52            bit bemf_cmp = 0;
  53            unsigned char eleci;
  54            eleccycle -= 1; 
C51 COMPILER V9.59.0.0   BLDC_SENSORLESS                                                   03/16/2019 10:51:47 PAGE 2   

  55            if(PreviousBEMF_CH == eleccycle)
  56            {
  57              DCBUS_Voltage = Phase_UVW_Voltage_ADC_Value[BEMF_DCT_Params1[eleccycle][DC_CH]];
  58          //    if(BEMF_DCT_Params1[eleccycle][SLOPE])
  59          //    {
  60          //      bemf_cmp = Phase_UVW_Voltage_ADC_Value[BEMF_DCT_Params1[eleccycle][BEMF_CH]] < (DCBUS_Voltage >> 1);
  61          //      if(Phase_UVW_Voltage_ADC_Value[BEMF_DCT_Params1[eleccycle][BEMF_CH]] < (DCBUS_Voltage >> MagDecayPuls
             -eDct))
  62          //        BEMF_Slope_Count = 0;
  63          //    }
  64          //    else
  65          //    {
  66          //      bemf_cmp = Phase_UVW_Voltage_ADC_Value[BEMF_DCT_Params1[eleccycle][BEMF_CH]] > (DCBUS_Voltage >> 1);  
  67          //      if(Phase_UVW_Voltage_ADC_Value[BEMF_DCT_Params1[eleccycle][BEMF_CH]] > (DCBUS_Voltage - (DCBUS_Voltag
             -e >> MagDecayPulseDct)))
  68          //        BEMF_Slope_Count = 0;
  69          //    }   DCBUS_Voltage = Phase_UVW_Voltage_ADC_Value[BEMF_DCT_Params1[eleccycle][DC_CH]];
  70              if(BEMF_DCT_Params1[eleccycle][SLOPE])
  71              {
  72                if((Phase_UVW_Voltage_ADC_Value[BEMF_DCT_Params1[eleccycle][BEMF_CH]] > (DCBUS_Voltage >> MagDecayPulse
             -Dct))&&(Prev_Phase_UVW_Voltage_ADC_Value[BEMF_DCT_Params1[eleccycle][BEMF_CH]] > Phase_UVW_Voltage_ADC_Value[BEMF_DCT_Pa
             -rams1[eleccycle][BEMF_CH]]))
  73                {
  74                    BEMF_Slope_Count++;
  75                    if((BEMF_Slope_Count >= MagDecayPulseCnt) && Phase_UVW_Voltage_ADC_Value[BEMF_DCT_Params1[eleccycle][
             -BEMF_CH]] < (DCBUS_Voltage >> 1))
  76                      bemf_cmp = 1;
  77                }
  78                else
  79                  BEMF_Slope_Count = 0;
  80              }
  81              else
  82              {     
  83                if((Phase_UVW_Voltage_ADC_Value[BEMF_DCT_Params1[eleccycle][BEMF_CH]] < (DCBUS_Voltage - (DCBUS_Voltage
             - >> MagDecayPulseDct)))&&(Prev_Phase_UVW_Voltage_ADC_Value[BEMF_DCT_Params1[eleccycle][BEMF_CH]] < Phase_UVW_Voltage_ADC
             -_Value[BEMF_DCT_Params1[eleccycle][BEMF_CH]]))
  84                {
  85                    BEMF_Slope_Count++;
  86                    if((BEMF_Slope_Count >= MagDecayPulseCnt) && Phase_UVW_Voltage_ADC_Value[BEMF_DCT_Params1[eleccycle][
             -BEMF_CH]] > (DCBUS_Voltage >> 1))
  87                      bemf_cmp = 1;
  88                }
  89                else
  90                  BEMF_Slope_Count = 0;
  91              }
  92              if(bemf_cmp)
  93              {
  94                eleci = eleccycle + 1;
  95                if(Last_Rtn != eleci)
  96                { 
  97            //      P07 = !P07;
  98                  Last_Rtn = eleci; 
  99                  return eleci; 
 100                }
 101              }
 102            }
 103            else
 104            { 
 105              BEMF_Slope_Count = 0;
 106          //    P07 = !P07;
 107              PreviousBEMF_CH = eleccycle;
 108            }
C51 COMPILER V9.59.0.0   BLDC_SENSORLESS                                                   03/16/2019 10:51:47 PAGE 3   

 109          //  P07 = 0;
 110            return 0;
 111          }*/
 112          
 113          
 114          unsigned char BEMF_Calculate(unsigned char eleccycle,unsigned int dcvolt,unsigned int bemf,bit pwmondct) u
             -sing 1
 115          { 
 116   1        bit bemf_cmp = 0;
 117   1        unsigned char eleci;
 118   1        eleccycle -= 1; 
 119   1        if(PreviousBEMF_CH == eleccycle)
 120   1        {
 121   2          
 122   2          if(BEMF_DCT_Params1[eleccycle][SLOPE])
 123   2          {
 124   3            if((!pwmondct||(bemf > (dcvolt >> MagDecayPulseDct)))&&(Prev_bemf > bemf))
 125   3            {
 126   4                BEMF_Slope_Count++;
 127   4                if((BEMF_Slope_Count >= MagDecayPulseCnt) && bemf < (dcvolt >> 1))
 128   4                  bemf_cmp = 1;
 129   4            }
 130   3            else
 131   3              BEMF_Slope_Count = 0;
 132   3          }
 133   2          else
 134   2          {     
 135   3            if((!pwmondct || ((bemf < (dcvolt - (dcvolt >> MagDecayPulseDct)))))&&(Prev_bemf < bemf))
 136   3            {
 137   4                BEMF_Slope_Count++;
 138   4                if((BEMF_Slope_Count >= MagDecayPulseCnt) && bemf > (dcvolt >> 1))
 139   4                  bemf_cmp = 1;
 140   4            }
 141   3            else
 142   3              BEMF_Slope_Count = 0;
 143   3          }
 144   2          Prev_bemf = bemf;
 145   2          if(bemf_cmp && (Zero_Cross_Count == 0))
 146   2          {
 147   3            Zero_Cross_Count = Switch_Count;
 148   3            Zero_Cross_Flag = 1;
 149   3          }
 150   2          if(Switch_Count >= (Zero_Cross_Count + (Period_Count >> 2) + (Period_Count >> 3)) && Zero_Cross_Flag)
 151   2          {       
 152   3            Zero_Cross_Flag = 0;
 153   3            eleci = eleccycle + 1;
 154   3            if(Last_Rtn != eleci)
 155   3            { 
 156   4              P07 = !P07;
 157   4              Last_Rtn = eleci; 
 158   4              Zero_Cross_Count = 0;
 159   4              return eleci; 
 160   4            }
 161   3          }
 162   2          Switch_Count ++;
 163   2        }
 164   1        else
 165   1        { 
 166   2          BEMF_Slope_Count = 0;
 167   2      //    P07 = !P07;
 168   2          PreviousBEMF_CH = eleccycle;
 169   2          Period_Count = Switch_Count;
C51 COMPILER V9.59.0.0   BLDC_SENSORLESS                                                   03/16/2019 10:51:47 PAGE 4   

 170   2          Switch_Count = 0;
 171   2        }
 172   1      //  P07 = 0;
 173   1        return 0;
 174   1      }
 175          
 176          void BEMF_Gpio_ADCIN_Init()
 177          {
 178   1        P0M1 |= 0x70;
 179   1        P0M2 &= 0x8f;
 180   1        AINDIDS  |= 0x3E;
 181   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    301    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =      2    ----
   DATA SIZE        =     27    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
